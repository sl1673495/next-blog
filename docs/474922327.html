<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta name="next-head-count" content="2"/><link rel="preload" href="/next-blog/_next/static/m5Gs-4quKLhv6MJso2_7j/pages/474922327.js" as="script"/><link rel="preload" href="/next-blog/_next/static/m5Gs-4quKLhv6MJso2_7j/pages/_app.js" as="script"/><link rel="preload" href="/next-blog/_next/static/chunks/42.804f640b9080257d2001.js" as="script"/><link rel="preload" href="/next-blog/_next/static/runtime/webpack-c213b3d658f42fde6232.js" as="script"/><link rel="preload" href="/next-blog/_next/static/chunks/commons.59358844195a85e5278d.js" as="script"/><link rel="preload" href="/next-blog/_next/static/runtime/main-b7de933161803ebe9106.js" as="script"/><link rel="stylesheet" href="/next-blog/_next/static/css/commons.8b6757c5.chunk.css"/></head><body><div id="__next"><div style="max-width:1000px;margin:auto;padding:20px"><div><h1 class="title"><a href="/">ssh的前端博客</a></h1></div><h1>用jsx封装Vue中的复杂组件（网易云音乐实战项目需求）</h1><div><h2 id="背景介绍">背景介绍</h2>
<p>最近在做vue高仿<a href="https://juejin.im/post/5d3c0765f265da1b60294b78">网易云音乐</a>的项目，在做的过程中发现音乐表格这个组件会被非常多的地方复用，而且需求比较复杂的和灵活。</p>
<h3 id="预览地址"><a href="http://47.99.213.231:8001/">预览地址</a></h3>
<h3 id="源码地址"><a href="https://github.com/sl1673495/vue-netease-music">源码地址</a></h3>
<h2 id="图片预览">图片预览</h2>
<ul>
<li>歌单详情<br><img src="https://user-gold-cdn.xitu.io/2019/7/31/16c45d24774d06bf?w=1209&h=481&f=png&s=154844" alt="歌单详情"></li>
<li>播放列表<br><img src="https://user-gold-cdn.xitu.io/2019/7/31/16c45d2920dc1634?w=391&h=358&f=png&s=53326" alt="播放列表"></li>
<li>搜索高亮<br><img src="https://user-gold-cdn.xitu.io/2019/7/31/16c46085f7a4c70c?w=1210&h=363&f=png&s=135056" alt="搜索高亮"></li>
</ul>
<h2 id="需求分析">需求分析</h2>
<p>它需要支持：</p>
<ul>
<li><p>hideColumns参数， 自定义需要隐藏哪些列。</p>
</li>
<li><p>highLightText，传入字符串，数据中命中的字符串高亮。</p>
</li>
</ul>
<p>首先 看一下我们平常的table写法。</p>
<pre><code class="language-javascript">  &lt;el-table
      :data=&quot;tableData&quot;
      style=&quot;width: 100%&quot;&gt;
      &lt;el-table-column
        prop=&quot;index&quot;
        label=&quot; &quot;
        width=&quot;180&quot;&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column
        prop=&quot;name&quot;
        label=&quot;音乐标题&quot;
        width=&quot;180&quot;&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column
        prop=&quot;artistsText&quot;
        label=&quot;歌手&quot;&gt;
      &lt;/el-table-column&gt;
    &lt;/el-table&gt;</code></pre>
<p>这是官网的写法，假设我们传入了 hideColumns: [&#39;index&#39;, &#39;name&#39;]，我们需要在模板里隐藏的话```</p>
<pre><code class="language-javascript">    &lt;el-table
      :data=&quot;tableData&quot;
      style=&quot;width: 100%&quot;&gt;
      &lt;el-table-column
    +++ v-if=&quot;!hideColumns.includes(&#39;index&#39;)&quot;
        prop=&quot;index&quot;
        label=&quot; &quot;
        width=&quot;180&quot;&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column
    +++ v-if=&quot;!hideColumns.includes(&#39;name&#39;)&quot;
        prop=&quot;name&quot;
        label=&quot;音乐标题&quot;
        width=&quot;180&quot;&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column
    +++ v-if=&quot;!hideColumns.includes(&#39;address&#39;)&quot;
        prop=&quot;artistsText&quot;
        label=&quot;歌手&quot;&gt;
      &lt;/el-table-column&gt;
    &lt;/el-table&gt;</code></pre>
<p>这种代码非常笨，所以我们肯定是接受不了的，我们很自然的联想到平常用v-for循环，能不能套用在这个需求上呢。<br>首先在data里定义columns</p>
<pre><code class="language-javascript">data() {
    return {
      columns: [{
        prop: &#39;index&#39;,
        label: &#39;&#39;,
        width: &#39;50&#39;
      }, {
        prop: &#39;artistsText&#39;,
        label: &#39;歌手&#39;
      }, {
        prop: &#39;albumName&#39;,
        label: &#39;专辑&#39;
      }, {
        prop: &#39;durationSecond&#39;,
        label: &#39;时长&#39;,
        width: &#39;100&#39;,
      }]
    }
}</code></pre>
<p>然后我们在computed中计算hideColumns做一次合并</p>
<pre><code class="language-javascript">  computed: {
    showColumns() {
      const { hideColumns } = this
      return this.columns.filter(column =&gt; {
        return !this.hideColumns.find((prop) =&gt; prop === column.prop)
      })
    },
  },</code></pre>
<p>那么模板里我们就可以简写成</p>
<pre><code class="language-javascript">&lt;el-table
    :data=&quot;songs&quot;
  &gt;
    &lt;template v-for=&quot;(column, index) in showColumns&quot;&gt;
      &lt;el-table-column
        :key=&quot;index&quot;
        // 混入属性
        v-bind=&quot;column&quot;
      &gt;
      &lt;/el-table-column&gt;
    &lt;/template&gt;
  &lt;/el-table&gt;</code></pre>
<p>注意<code>v-bind=&quot;column&quot;</code>这行， 相当于把column中的所有属性混入到table-column中去，是一个非常简便的方法。</p>
<h2 id="script配合template的解决方案">script配合template的解决方案</h2>
<p>这样需求看似解决了，很美好。<br></br><br>但是我们忘了非常重要的一点，<code>slotScopes</code>这个东西！</p>
<p>比如音乐时长我们需要format一下，</p>
<pre><code class="language-javascript"> &lt;el-table-column&gt;
     &lt;template&gt;
        &lt;span&gt;{{ $utils.formatTime(scope.row.durationSecond) }}&lt;/span&gt;
     &lt;/template&gt;
 &lt;/el-table-column&gt;</code></pre>
<p>但是我们现在把columns都写到script里了，和template分离开来了，我暂时还不知道有什么方法能把<code>sciprt</code>里写的模板放到<code>template</code>里用，所以先想到一个可以解决问题的方法。就是在template里加一些判断。</p>
<pre><code class="language-javascript">&lt;el-table
    v-bind=&quot;$attrs&quot;
    v-if=&quot;songs.length&quot;
    :data=&quot;songs&quot;
    @row-click=&quot;onRowClick&quot;
    :cell-class-name=&quot;tableCellClassName&quot;
    style=&quot;width: 99.9%&quot;
  &gt;
    &lt;template v-for=&quot;(column, index) in showColumns&quot;&gt;
      &lt;!-- 需要自定义渲染的列 --&gt;
      &lt;el-table-column
        v-if=&quot;[&#39;durationSecond&#39;].includes(column.prop)&quot;
        :key=&quot;index&quot;
        v-bind=&quot;column&quot;
      &gt;
          &lt;!-- 时长 --&gt;
          &lt;template v-else-if=&quot;column.prop === &#39;durationSecond&#39;&quot;&gt;
            &lt;span&gt;{{ $utils.formatTime(scope.row.durationSecond) }}&lt;/span&gt;
          &lt;/template&gt;
      &lt;/el-table-column&gt;

      &lt;!-- 普通列 --&gt;
      &lt;el-table-column
        v-else
        :key=&quot;index&quot;
        v-bind=&quot;column&quot;
      &gt;
      &lt;/el-table-column&gt;
    &lt;/template&gt;
  &lt;/el-table&gt;</code></pre>
<p>又一次的需求看似解决了，很美好。 </p>
<h2 id="高亮文字匹配需求分析">高亮文字匹配需求分析</h2>
</br>
但是新需求又来了！！根据传入的 highLightText 去高亮某些文字，我们分析一下需求
</br>

<p><code>鸡你太美</code>这个歌名，我们在搜索框输入<code>鸡你</code><br>我们需要把</p>
<pre><code>&lt;span&gt;鸡你太美&lt;/span&gt;</code></pre><p>转化为</p>
<pre><code>  &lt;span&gt;
    &lt;span class=&quot;high-light&quot;&gt;鸡你&lt;/span&gt;
    太美
 &lt;/span&gt;</code></pre><p>我们在template里找到音乐标题这行，写下这端代码：</p>
<pre><code class="language-javascript">&lt;template v-else-if=&quot;column.prop === &#39;name&#39;&quot;&gt;
  &lt;span&gt;{{this.genHighlight(scope.row.name)}}&lt;/span&gt;
&lt;/template&gt;</code></pre>
<pre><code class="language-javascript">methods: {
    genHighlight(text) {
       return &lt;span&gt;xxx&lt;/span&gt;
    }
}</code></pre>
<p>我发现无从下手了, 因为jsx最终编译成的是return vnode的方法，genHighlight执行以后返回的是vnode，但是你不能直接把vnode放到template里去。</p>
<h2 id="jsx终极解决方案">jsx终极解决方案</h2>
<p>所以我们要统一环境，直接使用jsx渲染我们的组件，文档可以参照<br></br><br><a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx">babel-plugin-transform-vue-jsx</a><br><br><br><a href="https://github.com/vuejs/jsx">vuejs/jsx</a></p>
<pre><code class="language-javascript">import ElTable from &#39;element-ui/lib/table&#39;

data() {
    const commonHighLightSlotScopes = {
      scopedSlots: {
        default: (scope) =&gt; {
          return (
            &lt;span&gt;{this.genHighlight(scope.row[scope.column.property])}&lt;/span&gt;
          )
        }
      }
    }
    return {
      columns: [{
        prop: &#39;name&#39;,
        label: &#39;音乐标题&#39;,
        ...commonHighLightSlotScopes
      }, {
        prop: &#39;artistsText&#39;,
        label: &#39;歌手&#39;,
         ...commonHighLightSlotScopes
      }, {
        prop: &#39;albumName&#39;,
        label: &#39;专辑&#39;,
        ...commonHighLightSlotScopes
      }, {
        prop: &#39;durationSecond&#39;,
        label: &#39;时长&#39;,
        width: &#39;100&#39;,
        scopedSlots: {
          default: (scope) =&gt; {
            return (
              &lt;span&gt;{this.$utils.formatTime(scope.row.durationSecond)}&lt;/span&gt;
            )
          }
        }
      }]
    }
  },
  methods: {
    genHighlight(title = &#39;&#39;) {
      ...省去一些细节
      const titleSpan = matchIndex &gt; -1 ? (
        &lt;span&gt;
          {beforeStr}
          &lt;span class=&quot;high-light-text&quot;&gt;{hitStr}&lt;/span&gt;
          {afterStr}
        &lt;/span&gt;
      ) : title;
      return titleSpan;
    },
  },
 render() {
    const elTableProps = ElTable.props
    // 从$attrs里提取作为prop的值
    // 这里要注意的点是驼峰命名法(camelCase)和短横线命名法(kebab-case)
    // 都是可以被组件接受的，虽然elTable里的prop定义的属性叫cellClassName
    // 但是我们要把cell-class-name也解析进prop里
    const { props, attrs } = genPropsAndAttrs(this.$attrs, elTableProps)

    const tableAttrs = {
      attrs,
      on: {
        ...this.$listeners,
        [&#39;row-click&#39;]: this.onRowClick,
      },
      props: {
        ...props,
        cellClassName: this.tableCellClassName,
        data: this.songs,
      },
      style: { width: &#39;99.9%&#39; }
    }
    return this.songs.length ? (
      &lt;el-table
        {...tableAttrs}
      &gt;
        {this.showColumns.map((column, index) =&gt; {
          const { scopedSlots, ...columnProps } = column
          return (
            &lt;el-table-column key={index} props={columnProps} scopedSlots={scopedSlots} &gt;
            &lt;/el-table-column&gt;
          )
        })}
      &lt;/el-table&gt;
    ) : null
  }</code></pre>
<p><code>attrs: this.$attrs</code> 注意这句话，我们在template里可以通过<br><code>v-bind=&quot;$attrs&quot;</code>去透传外部传进来的所有属性，<br>但是在jsx中我们必须分类清楚传给el-table的<code>attrs</code>和<code>props</code><br>比如el-table接受<code>data</code>这个prop，如果你放在attrs里传进去，那么就失效了。 </p>
<p>这个我暂时也没找到特别好的解决方法，只能先引用去拿elTable上的props去进行比对$attrs，取交集。</p>
<pre><code class="language-javascript">import ElTable from &#39;element-ui/lib/table&#39;
// 从$attrs里提取作为prop的值
// 这里要注意的点是驼峰命名法(camelCase)和短横线命名法(kebab-case)
// 都是可以被组件接受的，虽然elTable里的prop定义的属性叫cellClassName
// 但是我们要把cell-class-name也解析进prop里
const { props, attrs } = genPropsAndAttrs(this.$attrs, elTableProps)</code></pre>
<p>可以看到代码中模板的部分少了很多重复的判断，维护性和扩展性都更强了，jsx可以说是复杂组件的终极解决方案，但是要真正的封装好一个高阶组件，要做的还非常多。</p>
</div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/474922327","query":{},"buildId":"m5Gs-4quKLhv6MJso2_7j","assetPrefix":"/next-blog","nextExport":true,"dynamicIds":["+FGM","+fC4","0kiY","1LUk","28xz","2Vkh","3EHr","3gkP","3wag","4Q+X","4qfg","5VxD","5upZ","6ZBy","6k3J","6quq","73oX","75kF","7P7d","7mzT","7oys","8Kqh","8Pgg","8SK+","9Fqr","9G73","9JLW","9Mhc","9Nr/","9Q8I","9U8A","9c9R","9xzc","AIHI","Aayt","Agkw","AhXs","ApBa","Aqyh","AsRY","B05S","BIHe","BKhn","BLBw","BrQc","CyL5","D68y","DxbC","DzyG","E2cJ","EGmf","FIf5","FJ32","G+vv","G01c","GEZ5","GTAt","GgYO","GwJY","Gxxu","H2RM","H4p3","ImXp","JCUK","JGhL","Jb18","Jjkb","JopO","Jrxr","KK3C","KQfT","KUpP","KcjC","Kjk6","KpOm","KyKy","LOdI","LhHj","Ll1m","Lns6","Lo5G","LptB","MF4s","MQ8/","My+Z","NRrW","NyhX","OZ3z","PGlF","PziN","Q5ZB","QPTg","QQjU","QnJG","RLXu","ROUN","Rq6a","SF9x","SLii","Sl5E","T0rU","TdF3","UCcd","UFGb","UI5O","Uasv","VrLj","WSH0","Wj43","WtIr","Xfvt","YROV","YSo5","ZrqW","alHH","beiO","d4EH","ddo8","dnrZ","dycj","e8E9","ebWy","el66","fDA8","fEaW","fHEK","fP8y","fZ2E","gLO8","gmEm","gst6","hmeD","iTGd","ieeH","iobV","irpp","jKVu","jU8F","jW1C","jctj","kZ3Q","lE5/","lKKg","lRCX","lURu","ldBm","m/If","mBTZ","mY11","mzJY","n3/M","nwyE","o0In","oKc0","oU5B","oVRe","oVqn","on2m","ozyK","phP4","pvv5","pw5m","pxCe","qIW7","qUGr","qZUF","r0Rl","r7oX","rfnV","rnof","s8Vx","sM9k","sbla","syIQ","t6qC","tSgA","tluB","u0OR","u2N3","u34i","uIR8","uQpx","uR4j","unZW","vYiF","wB1n","wi1Z","xj1T","yOV0"]}</script><script async="" data-next-page="/474922327" src="/next-blog/_next/static/m5Gs-4quKLhv6MJso2_7j/pages/474922327.js"></script><script async="" data-next-page="/_app" src="/next-blog/_next/static/m5Gs-4quKLhv6MJso2_7j/pages/_app.js"></script><script async="" src="/next-blog/_next/static/chunks/42.804f640b9080257d2001.js"></script><script src="/next-blog/_next/static/runtime/webpack-c213b3d658f42fde6232.js" async=""></script><script src="/next-blog/_next/static/chunks/commons.59358844195a85e5278d.js" async=""></script><script src="/next-blog/_next/static/runtime/main-b7de933161803ebe9106.js" async=""></script></body></html>