<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta name="next-head-count" content="2"/><link rel="preload" href="/next-blog/_next/static/m5Gs-4quKLhv6MJso2_7j/pages/370996973.js" as="script"/><link rel="preload" href="/next-blog/_next/static/m5Gs-4quKLhv6MJso2_7j/pages/_app.js" as="script"/><link rel="preload" href="/next-blog/_next/static/chunks/42.804f640b9080257d2001.js" as="script"/><link rel="preload" href="/next-blog/_next/static/runtime/webpack-c213b3d658f42fde6232.js" as="script"/><link rel="preload" href="/next-blog/_next/static/chunks/commons.59358844195a85e5278d.js" as="script"/><link rel="preload" href="/next-blog/_next/static/runtime/main-b7de933161803ebe9106.js" as="script"/><link rel="stylesheet" href="/next-blog/_next/static/css/commons.8b6757c5.chunk.css"/></head><body><div id="__next"><div style="max-width:1000px;margin:auto;padding:20px"><div><h1 class="title"><a href="/">ssh的前端博客</a></h1></div><h1>Vue源码学习（4）计算属性computed</h1><div><p>上一篇讲解（摘抄）了Vue响应式实现的原理，良好的设计为很多看似复杂的功能奠定了基础，使得这些功能的实际实现变得很简单。</p>
<p><strong>我们先得出个结论，Watcher这个类即可以用做渲染函数的watcher， 也可以用作计算属性的Watcher，这两者在初始化和部分函数的分支都是不同的， watcher的更新核心方法是update，可以说计算属性的update是为了驱动渲染watcher的update，而渲染watcher的update是为了重新调用vm._update(vm._render())方法去更新真正的页面。</strong></p>
<p>首先来看初始化函数的简化版本</p>
<h3 id="initcomputed">initComputed</h3>
<pre><code class="language-js">function initComputed (vm: Component, computed: Object) {
  const watchers = vm._computedWatchers = Object.create(null)

  for (const key in computed) {
    const userDef = computed[key]
    const getter = typeof userDef === &#39;function&#39; ? userDef : userDef.get

   watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
    )

    if (!(key in vm)) {
      defineComputed(vm, key, userDef)
    }
  }
}</code></pre>
<p>vm就是vue实例，computed就是用户定义的computed对象。</p>
<p>首先定义了watchers数组和vm.__computedWatchers为一个空对象</p>
<pre><code class="language-js">  const watchers = vm._computedWatchers = Object.create(null)</code></pre>
<p>接下来遍历用户传入的computed对象，computed里面可以是</p>
<pre><code class="language-js">key: {
  get: ...,
  set: ...
}</code></pre>
<p>的形式，也可以是</p>
<pre><code class="language-js">key: function() {}</code></pre>
<p>的形式， 所以先取到这个getter函数，</p>
<pre><code class="language-js">const userDef = computed[key]
const getter = typeof userDef === &#39;function&#39; ? userDef : userDef.get</code></pre>
<p>然后为每个computed的key生成一个watcher观察者， getter就是用户传入的计算函数</p>
<pre><code class="language-js">watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
 )</code></pre>
<p>computedWatcherOptions其实就是{ computed: true }这个对象，这会使得watcher被初始化为计算属性的watcher（下文简称计算watcher）,</p>
<p>在watcher构造函数里有这么一段，<br>可以看到计算watcher的value被初始化为undefined，这说明了计算属性是惰性求值，并且计算watcher的实例下定义了this.dep = new Dep()。</p>
<pre><code class="language-js">if (this.computed) {
      this.value = undefined
      this.dep = new Dep()
    } else {
      this.value = this.get()
    }</code></pre>
<pre><code class="language-js">defineComputed(vm, key, userDef)</code></pre>
<p>在这之后调用了defineComputed把计算属性的key代理到了this下面，getter就定义为createComputedGetter(key),先看看createComputedGetter做了什么。</p>
<pre><code class="language-js">function createComputedGetter (key) {
  return function computedGetter () {
    const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]
    if (watcher) {
      watcher.depend()
      return watcher.evaluate()
    }
  }
}</code></pre>
<p>条件判断语句中有两句关键的代码，我们分开来看</p>
<pre><code class="language-js"> watcher.depend()
 return watcher.evaluate()</code></pre>
<h3 id="watcherdepend">watcher.depend()</h3>
<p>这个getter函数会在渲染模板遇到{{ computedValue }}这样的值的时候触发。<br>这时会先取到key对应的计算watcher， 并且调用watcher的depend()方法收集依赖。</p>
<pre><code class="language-js">  /**
   * Depend on this watcher. Only for computed property watchers.
   */
  depend () {
    if (this.dep &amp;&amp; Dep.target) {
      this.dep.depend()
    }
  }</code></pre>
<p>this.dep就是在初始化时为watcher生成的，可以思考一下在这个时候调用dep的depend会收集到什么，我们来看看dep的depend</p>
<pre><code class="language-js"> depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }
</code></pre>
<p>因为正在根据template生成对应的真实dom，所以这个时候的Dep.target一定是当前组件的<strong>渲染watcher</strong>，那么其实这个dep收集到的就是渲染watcher。</p>
<p>到这个时候，依赖收集完成了。 那我们接下来看</p>
<h3 id="return-watcherevaluate">return watcher.evaluate()</h3>
<pre><code class="language-js">  evaluate () {
    if (this.dirty) {
      this.value = this.get()
      this.dirty = false
    }
    return this.value
  }
</code></pre>
<p>这个其实是专为计算watcher设计的求值函数，this.dirty一定是在计算watcher的情况下才为true，<br>这时候会把this.value调用this.get()去求值，我们来看看this.get做了什么。</p>
<pre><code class="language-js">  get () {
    pushTarget(this)
    let value
    const vm = this.vm
    try {
      value = this.getter.call(vm, vm)
    } catch (e) {
      if (this.user) {
        handleError(e, vm, `getter for watcher &quot;${this.expression}&quot;`)
      } else {
        throw e
      }
    } finally {
      // &quot;touch&quot; every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value)
      }
      popTarget()
      this.cleanupDeps()
    }
    return value
  }</code></pre>
<p>首先调用pushTarget(this)， 把计算watcher设置为现在的全局Dep.target，这样其他的dep收集依赖就会收集到计算watcher了， 然后</p>
<pre><code class="language-js"> value = this.getter.call(vm, vm)</code></pre>
<p>这个时候的getter就会调用用户自定义的计算函数 比如</p>
<pre><code class="language-js">computed: {
  sum() {
     return this.a + this. b
  }
}</code></pre>
<p>那么此时的getter会去调用return this.a + this. b,<br>而在求这个值的过程中， 又会触发a和b的dep的depend， 这个时候a和b都会收集到这个计算watcher作为依赖</p>
<p>那么我们之后再一些methods里写this.a = 2 这样去改变a的值， 会触发a的dep去通知计算watcher去做update， 计算watcher的update方法又会去</p>
<pre><code class="language-js">this.dep.notify()</code></pre>
<p>触发watcher的dep的notify， 这个dep收集了渲染watcher， 这样会驱动渲染watcher去执行update()就会去重新渲染页面， 这样就达成了修改a属性去触发依赖a的视图和依赖sum的视图重新进行渲染。</p>
<pre><code class="language-js"> update () {
    queueWatcher(this)
  }</code></pre>
<p>queueWatcher会在nextTick执行watcher.run()</p>
<pre><code class="language-js">run () {
    if (this.active) {
      this.getAndInvoke(this.cb)
    }
  }</code></pre>
<p>此时的this.cb 是渲染watcher的cb 也就是vm._update(vm._render())<br>这样页面就会重新渲染，更新视图</p>
</div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/370996973","query":{},"buildId":"m5Gs-4quKLhv6MJso2_7j","assetPrefix":"/next-blog","nextExport":true,"dynamicIds":["+FGM","+fC4","0kiY","1LUk","28xz","2Vkh","3EHr","3gkP","3wag","4Q+X","4qfg","5VxD","5upZ","6ZBy","6k3J","6quq","73oX","75kF","7P7d","7mzT","7oys","8Kqh","8Pgg","8SK+","9Fqr","9G73","9JLW","9Mhc","9Nr/","9Q8I","9U8A","9c9R","9xzc","AIHI","Aayt","Agkw","AhXs","ApBa","Aqyh","AsRY","B05S","BIHe","BKhn","BLBw","BrQc","CyL5","D68y","DxbC","DzyG","E2cJ","EGmf","FIf5","FJ32","G+vv","G01c","GEZ5","GTAt","GgYO","GwJY","Gxxu","H2RM","H4p3","ImXp","JCUK","JGhL","Jb18","Jjkb","JopO","Jrxr","KK3C","KQfT","KUpP","KcjC","Kjk6","KpOm","KyKy","LOdI","LhHj","Ll1m","Lns6","Lo5G","LptB","MF4s","MQ8/","My+Z","NRrW","NyhX","OZ3z","PGlF","PziN","Q5ZB","QPTg","QQjU","QnJG","RLXu","ROUN","Rq6a","SF9x","SLii","Sl5E","T0rU","TdF3","UCcd","UFGb","UI5O","Uasv","VrLj","WSH0","Wj43","WtIr","Xfvt","YROV","YSo5","ZrqW","alHH","beiO","d4EH","ddo8","dnrZ","dycj","e8E9","ebWy","el66","fDA8","fEaW","fHEK","fP8y","fZ2E","gLO8","gmEm","gst6","hmeD","iTGd","ieeH","iobV","irpp","jKVu","jU8F","jW1C","jctj","kZ3Q","lE5/","lKKg","lRCX","lURu","ldBm","m/If","mBTZ","mY11","mzJY","n3/M","nwyE","o0In","oKc0","oU5B","oVRe","oVqn","on2m","ozyK","phP4","pvv5","pw5m","pxCe","qIW7","qUGr","qZUF","r0Rl","r7oX","rfnV","rnof","s8Vx","sM9k","sbla","syIQ","t6qC","tSgA","tluB","u0OR","u2N3","u34i","uIR8","uQpx","uR4j","unZW","vYiF","wB1n","wi1Z","xj1T","yOV0"]}</script><script async="" data-next-page="/370996973" src="/next-blog/_next/static/m5Gs-4quKLhv6MJso2_7j/pages/370996973.js"></script><script async="" data-next-page="/_app" src="/next-blog/_next/static/m5Gs-4quKLhv6MJso2_7j/pages/_app.js"></script><script async="" src="/next-blog/_next/static/chunks/42.804f640b9080257d2001.js"></script><script src="/next-blog/_next/static/runtime/webpack-c213b3d658f42fde6232.js" async=""></script><script src="/next-blog/_next/static/chunks/commons.59358844195a85e5278d.js" async=""></script><script src="/next-blog/_next/static/runtime/main-b7de933161803ebe9106.js" async=""></script></body></html>