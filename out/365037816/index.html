<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="referrer" content="no-referrer"/><link rel="stylesheet" href="/static/index.css" type="text/css"/><link rel="stylesheet" href="/static/hljs.css" type="text/css"/><link rel="stylesheet" href="/static/reset.css" type="text/css"/><link rel="stylesheet" href="/static/markdown.css" type="text/css"/><title>ssh的前端博客</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/Nc8mo8XGqmAgpgU6YAhfG/pages/365037816.js" as="script"/><link rel="preload" href="/_next/static/Nc8mo8XGqmAgpgU6YAhfG/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/chunks/22.bfe4263dd9514139326f.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-61b9af2a86c3f75f3f39.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.21d6495a20acbd049aff.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-7ca00c6bb257c339c190.js" as="script"/><style id="__jsx-4024170534">.title.jsx-4024170534{margin-top:0;margin-bottom:42px;}.title.jsx-4024170534 a.jsx-4024170534{color:var(--textTitle);-webkit-text-decoration:none;text-decoration:none;}</style><style id="__jsx-2472489444">body{--textTitle:rgb(255,167,196);}</style><style id="__jsx-4063293197">.title.jsx-1776941920{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;color:var(--textNormal);}.avatar.jsx-1776941920{width:50px;height:50px;border-radius:50%;}.comment.jsx-1776941920{margin-bottom:32px;border-bottom:1px solid #eee;}.user.jsx-1776941920{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.login.jsx-1776941920{color:var(--textLink);-webkit-text-decoration:none;text-decoration:none;}.avatar.jsx-1776941920{width:32px;height:32px;border-radius:50%;margin-right:8px;}</style></head><body><div id="__next"><div style="max-width:672px;margin:auto;padding:42px 21px"><div class="jsx-4024170534"><h2 class="jsx-4024170534 title"><a class="jsx-4024170534" href="/">ssh<!-- -->的前端博客</a></h2></div><div class="jsx-1776941920 markdown-body"><h1 class="jsx-1776941920 title">vue-router源码学习</h1><div><h3>初始化</h3>
<p>通过Vue.mixin混入beforeCreate方法执行初始化</p>
<p>根组件：
把this._routerRoot定义为根实例
子组件：
通过Vue.util.defineReactive把_route作为响应式对象定义到Vue实例this下(指向this._router.history.current)，
并且把子组件的this._routerRoot指向根实例</p>
<p>通过Vue.component将router-view和router-link注册成全局组件</p>
<p>通过Object.defineProperty往Vue.prototype上挂上了
$router(指向this._routerCurrent._router)
$router(指向this._routerCurrent._route 之前被定义为响应式了)
所以每个Vue实例都可以拿到这俩个很重要的对象。</p>
<h3>hash路由模式</h3>
<p>回退： 监听浏览器的popstate或hashchange事件，重新执行transitionTo方法。
改变： 调用window.history的pushState、replaceState api</p>
<p>this.$router.push 本质上调用了内部history实例的push方法，计算出带hash值的新路径，执行transitionTo切换路由。</p>
<h3>router-view：</h3>
<p>funcitional component
在render函数的第二个参数可以解构出{props, children, parent, data}
通过 const h = parent.$createElement 拿到父组件的Vue实例的创建VNode方法。</p>
<p>初始化:</p>
<pre><code class="language-js">    data.routerView = true
    // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots
    // 这个注释值得注意，因为调用了父组件的createElement 所以context是父组件实例，
    // 之前在学习Vue源码的slot部分有注意到 命名slot只有在context正确的情况下才会渲染
    const h = parent.$createElement
    const name = props.name
    const route = parent.$route
    const cache = parent._routerViewCache || (parent._routerViewCache = {})
</code></pre>
<p>通过初始化时候定义的data.routerView = true网上寻找父组件的routerView
从而确定routerView的层级，这个层级可以用来匹配router配置里的层级，方便找到应该渲染的组件!</p>
<pre><code class="language-js">    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    let depth = 0
    let inactive = false
    while (parent &amp;&amp; parent._routerRoot !== parent) {
      // 父组件的data.routerView为true 说明是嵌套的router-view 将depth + 1
      if (parent.$vnode &amp;&amp; parent.$vnode.data.routerView) {
        depth++
      }
      if (parent._inactive) {
        inactive = true
      }
      parent = parent.$parent
    }
    // 记录这个routerView的深度
    data.routerViewDepth = depth
</code></pre>
<p>通过depth 和route.matched这个records数组 找到对应的组件 并且cache下来</p>
<pre><code class="language-js">   // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children)
    }

    const matched = route.matched[depth]
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null
      return h()
    }

    const component = cache[name] = matched.components[name]
</code></pre>
<p>渲染组件。</p>
<pre><code class="language-js"> return h(component, data, children)
</code></pre>
<p>另外来看 中间有一段给data上挂载registerRouteInstance方法
这个方法会在初始化的时候指定beforeCreate调用 registerInstance(this, this) 也就是注册为当前实例
并且destory调用 registerInstance(this) 也就是注册为空，销毁
这个实例是给vue-router内部生成导航守卫时用的</p>
<pre><code class="language-js">    // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks
    data.registerRouteInstance = (vm, val) =&gt; {
      // val could be undefined for unregistration
      const current = matched.instances[name]
      if (
        (val &amp;&amp; current !== vm) ||
        (!val &amp;&amp; current === vm)
      ) {
        matched.instances[name] = val
      }
    }
</code></pre>
<p>写到这里 为什么路径切换了 router-view会重新render还是个悬念，接下来我们揭晓：
在初始化的时候，_route被定义为响应式属性了。
router-view的render刚开始的</p>
<pre><code class="language-js">    const route = parent.$route
</code></pre>
<p>这段代码访问了$route, 收集到了依赖,
在init中有一个监听, 对_route做了修改， 此时就会触发Watcher的重新渲染</p>
<pre><code class="language-js">    history.listen(route =&gt; {
      this.apps.forEach((app) =&gt; {
        app._route = route
      })
    })
</code></pre>
</div><div class="jsx-1776941920 comments"></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/365037816","query":{},"buildId":"Nc8mo8XGqmAgpgU6YAhfG","nextExport":true,"dynamicIds":["+FGM","+fC4","0kiY","1LUk","28xz","2Vkh","3EHr","3gkP","3wag","4Q+X","4qfg","5VxD","5upZ","6ZBy","6k3J","6quq","73oX","75kF","7P7d","7mzT","7oys","8Kqh","8Pgg","8SK+","9Fqr","9G73","9JLW","9Mhc","9Nr/","9Q8I","9U8A","9c9R","9xzc","AIHI","Aayt","Agkw","AhXs","ApBa","Aqyh","AsRY","B05S","BIHe","BKhn","BLBw","BrQc","CyL5","D68y","DxbC","DzyG","E2cJ","EGmf","FIf5","FJ32","G+vv","G01c","GEZ5","GTAt","GgYO","GwJY","Gxxu","H2RM","H4p3","ImXp","JCUK","JGhL","Jb18","Jjkb","JopO","Jrxr","KK3C","KQfT","KUpP","KcjC","Kjk6","KpOm","KyKy","LOdI","LhHj","Ll1m","Lns6","Lo5G","LptB","MF4s","MQ8/","My+Z","NRrW","NyhX","OZ3z","PGlF","PziN","Q5ZB","QPTg","QQjU","QnJG","RLXu","ROUN","Rq6a","SF9x","SLii","Sl5E","T0rU","TdF3","UCcd","UFGb","UI5O","Uasv","VrLj","WSH0","Wj43","WtIr","Xfvt","YROV","YSo5","ZrqW","alHH","beiO","d4EH","ddo8","dnrZ","dycj","e8E9","ebWy","el66","fDA8","fEaW","fHEK","fP8y","fZ2E","gLO8","gmEm","gst6","hmeD","iTGd","ieeH","iobV","irpp","jKVu","jU8F","jW1C","jctj","kZ3Q","lE5/","lKKg","lRCX","lURu","ldBm","m/If","mBTZ","mY11","mzJY","n3/M","nwyE","o0In","oKc0","oU5B","oVRe","oVqn","on2m","ozyK","phP4","pvv5","pw5m","pxCe","qIW7","qUGr","qZUF","r0Rl","r7oX","rfnV","rnof","s8Vx","sM9k","sbla","syIQ","t6qC","tSgA","tluB","u0OR","u2N3","u34i","uIR8","uQpx","uR4j","unZW","vYiF","wB1n","wi1Z","xj1T","yOV0"]}</script><script async="" data-next-page="/365037816" src="/_next/static/Nc8mo8XGqmAgpgU6YAhfG/pages/365037816.js"></script><script async="" data-next-page="/_app" src="/_next/static/Nc8mo8XGqmAgpgU6YAhfG/pages/_app.js"></script><script async="" src="/_next/static/chunks/22.bfe4263dd9514139326f.js"></script><script src="/_next/static/runtime/webpack-61b9af2a86c3f75f3f39.js" async=""></script><script src="/_next/static/chunks/commons.21d6495a20acbd049aff.js" async=""></script><script src="/_next/static/runtime/main-7ca00c6bb257c339c190.js" async=""></script></body></html>