<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="referrer" content="no-referrer"/><link rel="stylesheet" href="/static/index.css" type="text/css"/><link rel="stylesheet" href="/static/hljs.css" type="text/css"/><link rel="stylesheet" href="/static/reset.css" type="text/css"/><link rel="stylesheet" href="/static/markdown.css" type="text/css"/><title>ssh的前端博客</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/hEKywNj06atDn3wKWx2gf/pages/368466119.js" as="script"/><link rel="preload" href="/_next/static/hEKywNj06atDn3wKWx2gf/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/chunks/22.bfe4263dd9514139326f.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-61b9af2a86c3f75f3f39.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.a1043c35677aeb4954a8.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-7ca00c6bb257c339c190.js" as="script"/><style id="__jsx-4024170534">.title.jsx-4024170534{margin-top:0;margin-bottom:42px;}.title.jsx-4024170534 a.jsx-4024170534{color:var(--textTitle);-webkit-text-decoration:none;text-decoration:none;}</style><style id="__jsx-2472489444">body{--textTitle:rgb(255,167,196);}</style><style id="__jsx-4063293197">.title.jsx-1776941920{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;color:var(--textNormal);}.avatar.jsx-1776941920{width:50px;height:50px;border-radius:50%;}.comment.jsx-1776941920{margin-bottom:32px;border-bottom:1px solid #eee;}.user.jsx-1776941920{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.login.jsx-1776941920{color:var(--textLink);-webkit-text-decoration:none;text-decoration:none;}.avatar.jsx-1776941920{width:32px;height:32px;border-radius:50%;margin-right:8px;}</style></head><body><div id="__next"><div style="max-width:672px;margin:auto;padding:42px 21px"><div class="jsx-4024170534"><h2 class="jsx-4024170534 title"><a class="jsx-4024170534" href="/">ssh<!-- -->的前端博客</a></h2></div><div class="jsx-1776941920 markdown-body"><h1 class="jsx-1776941920 title">react-component源码学习（2） rc-steps</h1><div><p>rc-steps是antd的步骤组件所依赖的底层组件，先看官方给的用法示例。</p>
<pre><code class="language-js">&lt;Steps current={1}&gt;
  &lt;Steps.Step title=&quot;first&quot; /&gt;
  &lt;Steps.Step title=&quot;second&quot; /&gt;
  &lt;Steps.Step title=&quot;third&quot; /&gt;
&lt;/Steps&gt;
</code></pre>
<p>简洁明了的父子嵌套组件。
先从父组件的源码看起。</p>
<h2>Steps.jsx</h2>
<pre><code class="language-js">/* eslint react/no-did-mount-set-state: 0 */
import React, { cloneElement, Children, Component } from 'react';
import PropTypes from 'prop-types';
import { findDOMNode } from 'react-dom';
import classNames from 'classnames';
import debounce from 'lodash/debounce';
import { isFlexSupported } from './utils';

export default class Steps extends Component {
  static propTypes = {
    prefixCls: PropTypes.string,
    className: PropTypes.string,
    iconPrefix: PropTypes.string,
    direction: PropTypes.string,
    labelPlacement: PropTypes.string,
    children: PropTypes.any,
    status: PropTypes.string,
    size: PropTypes.string,
    progressDot: PropTypes.oneOfType([
      PropTypes.bool,
      PropTypes.func,
    ]),
    style: PropTypes.object,
    initial: PropTypes.number,
    current: PropTypes.number,
    icons: PropTypes.shape({
      finish: PropTypes.node,
      error: PropTypes.node,
    }),
  };
  static defaultProps = {
    prefixCls: 'rc-steps',
    iconPrefix: 'rc',
    direction: 'horizontal',
    labelPlacement: 'horizontal',
    initial: 0,
    current: 0,
    status: 'process',
    size: '',
    progressDot: false,
  };
  constructor(props) {
    super(props);
    this.state = {
      flexSupported: true,
      lastStepOffsetWidth: 0,
    };
    this.calcStepOffsetWidth = debounce(this.calcStepOffsetWidth, 150);
  }
  componentDidMount() {
    this.calcStepOffsetWidth();
    if (!isFlexSupported()) {
      this.setState({
        flexSupported: false,
      });
    }
  }
  componentDidUpdate() {
    this.calcStepOffsetWidth();
  }
  componentWillUnmount() {
    if (this.calcTimeout) {
      clearTimeout(this.calcTimeout);
    }
    if (this.calcStepOffsetWidth &amp;&amp; this.calcStepOffsetWidth.cancel) {
      this.calcStepOffsetWidth.cancel();
    }
  }
  calcStepOffsetWidth = () =&gt; {
    if (isFlexSupported()) {
      return;
    }
    // Just for IE9
    const domNode = findDOMNode(this);
    if (domNode.children.length &gt; 0) {
      if (this.calcTimeout) {
        clearTimeout(this.calcTimeout);
      }
      this.calcTimeout = setTimeout(() =&gt; {
        // +1 for fit edge bug of digit width, like 35.4px
        const lastStepOffsetWidth = (domNode.lastChild.offsetWidth || 0) + 1;
        // Reduce shake bug
        if (this.state.lastStepOffsetWidth === lastStepOffsetWidth ||
          Math.abs(this.state.lastStepOffsetWidth - lastStepOffsetWidth) &lt;= 3) {
          return;
        }
        this.setState({ lastStepOffsetWidth });
      });
    }
  }
  render() {
    const {
      prefixCls, style = {}, className, children, direction,
      labelPlacement, iconPrefix, status, size, current, progressDot, initial,
      icons,
      ...restProps,
    } = this.props;
    const { lastStepOffsetWidth, flexSupported } = this.state;
    const filteredChildren = React.Children.toArray(children).filter(c =&gt; !!c);
    const lastIndex = filteredChildren.length - 1;
    const adjustedlabelPlacement = !!progressDot ? 'vertical' : labelPlacement;
    const classString = classNames(prefixCls, `${prefixCls}-${direction}`, className, {
      [`${prefixCls}-${size}`]: size,
      [`${prefixCls}-label-${adjustedlabelPlacement}`]: direction === 'horizontal',
      [`${prefixCls}-dot`]: !!progressDot,
    });

    return (
      &lt;div className={classString} style={style} {...restProps}&gt;
        {
          Children.map(filteredChildren, (child, index) =&gt; {
            if (!child) {
              return null;
            }
            const stepNumber = initial + index;
            const childProps = {
              stepNumber: `${stepNumber + 1}`,
              prefixCls,
              iconPrefix,
              wrapperStyle: style,
              progressDot,
              icons,
              ...child.props,
            };
            if (!flexSupported &amp;&amp; direction !== 'vertical' &amp;&amp; index !== lastIndex) {
              childProps.itemWidth = `${100 / lastIndex}%`;
              childProps.adjustMarginRight = -Math.round(lastStepOffsetWidth / lastIndex + 1);
            }
            // fix tail color
            if (status === 'error' &amp;&amp; index === current - 1) {
              childProps.className = `${prefixCls}-next-error`;
            }
            if (!child.props.status) {
              if (stepNumber === current) {
                childProps.status = status;
              } else if (stepNumber &lt; current) {
                childProps.status = 'finish';
              } else {
                childProps.status = 'wait';
              }
            }
            return cloneElement(child, childProps);
          })
        }
      &lt;/div&gt;
    );
  }
}

</code></pre>
<p>首先看到在componentDidMount, componentDidUpdate阶段都调用了calcStepOffsetWidth这个方法，这个方法其实就是计算lastStepOffsetWidth最后一个步骤条的偏移距离 用来调整子组件的间距到正好撑满容器的效果。</p>
<h3>calcStepOffsetWidth</h3>
<p>在这个方法的开头，我们看到</p>
<pre><code class="language-js">if (isFlexSupported()) {
   return;
}
</code></pre>
<p>如果浏览器支持flex，就直接return，因为flex本身就是弹性自适应布局，</p>
<pre><code class="language-js">export function isFlexSupported() {
  if (typeof window !== 'undefined' &amp;&amp; window.document &amp;&amp; window.document.documentElement) {
    const { documentElement } = window.document;
    return 'flex' in documentElement.style ||
      'webkitFlex' in documentElement.style ||
      'Flex' in documentElement.style ||
      'msFlex' in documentElement.style;
  }
  return false;
}
</code></pre>
<p>如果不支持flex，
则先用React.findDomNode(this)拿到当前组件的dom节点，然后用了一个类似debouce的处理，利用setTimout在下一个事件循环里处理，并且保证一个事件循环里触发的多次此方法被归并成一次，
拿到children中lastChild的offsetWidth并且赋给state的lastStepOffsetWidth。</p>
<h3>render</h3>
<p>filteredChildren是利用React.Children.toArray把子节点转成数组且过滤掉空节点，然后拿到lastIndex最后一项的序号，在最后的return中调用React.Children.map循环子节点数组，在这个循环中，stepNumber是props.initial + index，childProps在child原有的props基础上扩展了
stepNumber步骤序号和一系列样式，</p>
<pre><code class="language-js">if (!flexSupported &amp;&amp; direction !== 'vertical' &amp;&amp; index !== lastIndex) {
      childProps.itemWidth = `${100 / lastIndex}%`;
      childProps.adjustMarginRight = -Math.round(lastStepOffsetWidth / lastIndex + 1);
}
</code></pre>
<p>在不支持flex的情况下继续扩展
itemWidth为 100除以最后一项的下标
adjustMarginRight 是上面计算的lastStepOffsetWidth除以子元素数量并取负。</p>
<pre><code class="language-js">// fix tail color
   if (status === 'error' &amp;&amp; index === current - 1) {
  childProps.className = `${prefixCls}-next-error`;
}
</code></pre>
<p>status代表props中传入的当前步骤的状态，如果是错误并且这时候的step是当前步骤的前一个的话，加一个next-error的class</p>
<pre><code class="language-js">          if (!child.props.status) {
              if (stepNumber === current) {
                childProps.status = status;
              } else if (stepNumber &lt; current) {
                childProps.status = 'finish';
              } else {
                childProps.status = 'wait';
              }
            }
</code></pre>
<p>这段是假设用户不传入status的情况下自动计算当前应该的状态，
current之前是finished 之后是wait</p>
<pre><code class="language-js"> return cloneElement(child, childProps);
</code></pre>
<p>最后调用React.cloneElement把child和childProps合并成一个新节点返回。</p>
<h2>Step.jsx</h2>
<pre><code class="language-js">import React from 'react';
import PropTypes from 'prop-types';
import classNames from 'classnames';

function isString(str) {
  return typeof str === 'string';
}

export default class Step extends React.Component {
  static propTypes = {
    className: PropTypes.string,
    prefixCls: PropTypes.string,
    style: PropTypes.object,
    wrapperStyle: PropTypes.object,
    itemWidth: PropTypes.oneOfType([
      PropTypes.number,
      PropTypes.string,
    ]),
    status: PropTypes.string,
    iconPrefix: PropTypes.string,
    icon: PropTypes.node,
    adjustMarginRight: PropTypes.oneOfType([
      PropTypes.number,
      PropTypes.string,
    ]),
    stepNumber: PropTypes.string,
    description: PropTypes.any,
    title: PropTypes.any,
    progressDot: PropTypes.oneOfType([
      PropTypes.bool,
      PropTypes.func,
    ]),
    tailContent: PropTypes.any,
    icons: PropTypes.shape({
      finish: PropTypes.node,
      error: PropTypes.node,
    }),
  };
  renderIconNode() {
    const {
      prefixCls, progressDot, stepNumber, status, title, description, icon,
      iconPrefix, icons,
    } = this.props;
    let iconNode;
    const iconClassName = classNames(`${prefixCls}-icon`, `${iconPrefix}icon`, {
      [`${iconPrefix}icon-${icon}`]: icon &amp;&amp; isString(icon),
      [`${iconPrefix}icon-check`]: !icon &amp;&amp; status === 'finish' &amp;&amp; (icons &amp;&amp; !icons.finish),
      [`${iconPrefix}icon-close`]: !icon &amp;&amp; status === 'error' &amp;&amp; (icons &amp;&amp; !icons.error),
    });
    const iconDot = &lt;span className={`${prefixCls}-icon-dot`}&gt;&lt;/span&gt;;
    // `progressDot` enjoy the highest priority
    if (progressDot) {
      if (typeof progressDot === 'function') {
        iconNode = (
          &lt;span className={`${prefixCls}-icon`}&gt;
            {progressDot(iconDot, { index: stepNumber - 1, status, title, description })}
          &lt;/span&gt;
        );
      } else {
        iconNode = &lt;span className={`${prefixCls}-icon`}&gt;{iconDot}&lt;/span&gt;;
      }
    } else if (icon &amp;&amp; !isString(icon)) {
      iconNode = &lt;span className={`${prefixCls}-icon`}&gt;{icon}&lt;/span&gt;;
    } else if (icons &amp;&amp; icons.finish &amp;&amp; status === 'finish') {
      iconNode = &lt;span className={`${prefixCls}-icon`}&gt;{icons.finish}&lt;/span&gt;;
    } else if (icons &amp;&amp; icons.error &amp;&amp; status === 'error') {
      iconNode = &lt;span className={`${prefixCls}-icon`}&gt;{icons.error}&lt;/span&gt;;
    } else if (icon || status === 'finish' || status === 'error') {
      iconNode = &lt;span className={iconClassName} /&gt;;
    } else {
      iconNode = &lt;span className={`${prefixCls}-icon`}&gt;{stepNumber}&lt;/span&gt;;
    }

    return iconNode;
  }
  render() {
    const {
      className, prefixCls, style, itemWidth,
      status = 'wait', iconPrefix, icon, wrapperStyle,
      adjustMarginRight, stepNumber,
      description, title, progressDot, tailContent,
      icons,
      ...restProps,
    } = this.props;

    const classString = classNames(
      `${prefixCls}-item`,
      `${prefixCls}-item-${status}`,
      className,
      { [`${prefixCls}-item-custom`]: icon },
    );
    const stepItemStyle = { ...style };
    if (itemWidth) {
      stepItemStyle.width = itemWidth;
    }
    if (adjustMarginRight) {
      stepItemStyle.marginRight = adjustMarginRight;
    }
    return (
      &lt;div
        {...restProps}
        className={classString}
        style={stepItemStyle}
      &gt;
        &lt;div className={`${prefixCls}-item-tail`}&gt;
          {tailContent}
        &lt;/div&gt;
        &lt;div className={`${prefixCls}-item-icon`}&gt;
          {this.renderIconNode()}
        &lt;/div&gt;
        &lt;div className={`${prefixCls}-item-content`}&gt;
          &lt;div className={`${prefixCls}-item-title`}&gt;
            {title}
          &lt;/div&gt;
          {description &amp;&amp; &lt;div className={`${prefixCls}-item-description`}&gt;{description}&lt;/div&gt;}
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

</code></pre>
<p>子组件里就是根据父组件计算的一些props和本身的props计算出图标和状态进行渲染。</p>
</div><div class="jsx-1776941920 comments"></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/368466119","query":{},"buildId":"hEKywNj06atDn3wKWx2gf","nextExport":true,"dynamicIds":["+FGM","+fC4","0kiY","1LUk","28xz","2Vkh","3EHr","3gkP","3wag","4Q+X","4qfg","5VxD","5upZ","6ZBy","6k3J","6quq","73oX","75kF","7P7d","7mzT","7oys","8Kqh","8Pgg","8SK+","9Fqr","9G73","9JLW","9Mhc","9Nr/","9Q8I","9U8A","9c9R","9xzc","AIHI","Aayt","Agkw","AhXs","ApBa","Aqyh","AsRY","B05S","BIHe","BKhn","BLBw","BrQc","CyL5","D68y","DxbC","DzyG","E2cJ","EGmf","FIf5","FJ32","G+vv","G01c","GEZ5","GTAt","GgYO","GwJY","Gxxu","H2RM","H4p3","ImXp","JCUK","JGhL","Jb18","Jjkb","JopO","Jrxr","KK3C","KQfT","KUpP","KcjC","Kjk6","KpOm","KyKy","LOdI","LhHj","Ll1m","Lns6","Lo5G","LptB","MF4s","MQ8/","My+Z","NRrW","NyhX","OZ3z","PGlF","PziN","Q5ZB","QPTg","QQjU","QnJG","RLXu","ROUN","Rq6a","SF9x","SLii","Sl5E","T0rU","TdF3","UCcd","UFGb","UI5O","Uasv","VrLj","WSH0","Wj43","WtIr","Xfvt","YROV","YSo5","ZrqW","alHH","beiO","d4EH","ddo8","dnrZ","dycj","e8E9","ebWy","el66","fDA8","fEaW","fHEK","fP8y","fZ2E","gLO8","gmEm","gst6","hmeD","iTGd","ieeH","iobV","irpp","jKVu","jU8F","jW1C","jctj","kZ3Q","lE5/","lKKg","lRCX","lURu","ldBm","m/If","mBTZ","mY11","mzJY","n3/M","nwyE","o0In","oKc0","oU5B","oVRe","oVqn","on2m","ozyK","phP4","pvv5","pw5m","pxCe","qIW7","qUGr","qZUF","r0Rl","r7oX","rfnV","rnof","s8Vx","sM9k","sbla","syIQ","t6qC","tSgA","tluB","u0OR","u2N3","u34i","uIR8","uQpx","uR4j","unZW","vYiF","wB1n","wi1Z","xj1T","yOV0"]}</script><script async="" data-next-page="/368466119" src="/_next/static/hEKywNj06atDn3wKWx2gf/pages/368466119.js"></script><script async="" data-next-page="/_app" src="/_next/static/hEKywNj06atDn3wKWx2gf/pages/_app.js"></script><script async="" src="/_next/static/chunks/22.bfe4263dd9514139326f.js"></script><script src="/_next/static/runtime/webpack-61b9af2a86c3f75f3f39.js" async=""></script><script src="/_next/static/chunks/commons.a1043c35677aeb4954a8.js" async=""></script><script src="/_next/static/runtime/main-7ca00c6bb257c339c190.js" async=""></script></body></html>