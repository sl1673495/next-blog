<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="referrer" content="no-referrer"/><link rel="stylesheet" href="/static/index.css" type="text/css"/><link rel="stylesheet" href="/static/hljs.css" type="text/css"/><link rel="stylesheet" href="/static/reset.css" type="text/css"/><link rel="stylesheet" href="/static/markdown.css" type="text/css"/><title>ssh的前端博客</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/hEKywNj06atDn3wKWx2gf/pages/367088504.js" as="script"/><link rel="preload" href="/_next/static/hEKywNj06atDn3wKWx2gf/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/chunks/22.bfe4263dd9514139326f.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-61b9af2a86c3f75f3f39.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.a1043c35677aeb4954a8.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-7ca00c6bb257c339c190.js" as="script"/><style id="__jsx-4024170534">.title.jsx-4024170534{margin-top:0;margin-bottom:42px;}.title.jsx-4024170534 a.jsx-4024170534{color:var(--textTitle);-webkit-text-decoration:none;text-decoration:none;}</style><style id="__jsx-2472489444">body{--textTitle:rgb(255,167,196);}</style><style id="__jsx-4063293197">.title.jsx-1776941920{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;color:var(--textNormal);}.avatar.jsx-1776941920{width:50px;height:50px;border-radius:50%;}.comment.jsx-1776941920{margin-bottom:32px;border-bottom:1px solid #eee;}.user.jsx-1776941920{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.login.jsx-1776941920{color:var(--textLink);-webkit-text-decoration:none;text-decoration:none;}.avatar.jsx-1776941920{width:32px;height:32px;border-radius:50%;margin-right:8px;}</style></head><body><div id="__next"><div style="max-width:672px;margin:auto;padding:42px 21px"><div class="jsx-4024170534"><h2 class="jsx-4024170534 title"><a class="jsx-4024170534" href="/">ssh<!-- -->的前端博客</a></h2></div><div class="jsx-1776941920 markdown-body"><h1 class="jsx-1776941920 title">react-component源码学习（1） rc-form</h1><div><p>rc-form作为ant-design系列实现表单组件的底层组件， 通用性和强大的功能兼得，这得益于它底层的精妙实现，rc-form是典型的高阶组件（higher-order component）</p>
<p>下面从一个官方的简单示例说起。</p>
<pre><code class="language-js">import { createForm, formShape } from 'rc-form';

class Form extends React.Component {
  static propTypes = {
    form: formShape,
  };

  submit = () =&gt; {
    this.props.form.validateFields((error, value) =&gt; {
      console.log(error, value);
    });
  }

  render() {
    let errors;
    const { getFieldProps, getFieldError } = this.props.form;
    return (
      &lt;div&gt;
        &lt;input {...getFieldProps('normal')}/&gt;
        &lt;input {...getFieldProps('required', {
          onChange(){}, // have to write original onChange here if you need
          rules: [{required: true}],
        })}/&gt;
        {(errors = getFieldError('required')) ? errors.join(',') : null}
        &lt;button onClick={this.submit}&gt;submit&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export createForm()(Form);
</code></pre>
<p>可以看到在最后用createForm这个函数执行返回的函数包裹了Form组件，
正因为如此在render中才可以从props里拿到from， 这是rc-form提供给我们的，接下来看看这个form是如何注入进去的。</p>
<h3>createForm.js</h3>
<pre><code class="language-js">import createBaseForm from './createBaseForm';

export const mixin = {
  getForm() {
    return {
      getFieldsValue: this.fieldsStore.getFieldsValue,
      getFieldValue: this.fieldsStore.getFieldValue,
      getFieldInstance: this.getFieldInstance,
      setFieldsValue: this.setFieldsValue,
      setFields: this.setFields,
      setFieldsInitialValue: this.fieldsStore.setFieldsInitialValue,
      getFieldDecorator: this.getFieldDecorator,
      getFieldProps: this.getFieldProps,
      getFieldsError: this.fieldsStore.getFieldsError,
      getFieldError: this.fieldsStore.getFieldError,
      isFieldValidating: this.fieldsStore.isFieldValidating,
      isFieldsValidating: this.fieldsStore.isFieldsValidating,
      isFieldsTouched: this.fieldsStore.isFieldsTouched,
      isFieldTouched: this.fieldsStore.isFieldTouched,
      isSubmitting: this.isSubmitting,
      submit: this.submit,
      validateFields: this.validateFields,
      resetFields: this.resetFields,
    };
  },
};

function createForm(options) {
  return createBaseForm(options, [mixin]);
}

export default createForm;

</code></pre>
<p>这是我们在render中调用的createForm 可以看到mixin中的getForm里的属性和我们使用的很相似，其实这就是最终注入的props.form属性， 对外暴露的createForm方法最终调用了createBaseForm并将mixin传入。</p>
<h3>createBaseForm.js</h3>
<pre><code class="language-js">function createBaseForm(option = {}, mixins = []) {
  const {
    validateMessages,
    onFieldsChange,
    onValuesChange,
    mapProps = identity,
    mapPropsToFields,
    fieldNameProp,
    fieldMetaProp,
    fieldDataProp,
    formPropName = 'form',
    name: formName,
    // @deprecated
    withRef,
  } = option;

  return function decorate(WrappedComponent) {
    const Form = createReactClass({
      mixins,
      .......,
      render() {
        const { wrappedComponentRef, ...restProps } = this.props;
        const formProps = {
          [formPropName]: this.getForm(),
        };
        if (withRef) {
          if (process.env.NODE_ENV !== 'production' &amp;&amp; process.env.NODE_ENV !== 'test') {
            warning(
              false,
              '`withRef` is deprecated, please use `wrappedComponentRef` instead. ' +
                'See: https://github.com/react-component/form#note-use-wrappedcomponentref-instead-of-withref-after-rc-form140'
            );
          }
          formProps.ref = 'wrappedComponent';
        } else if (wrappedComponentRef) {
          formProps.ref = wrappedComponentRef;
        }
        const props = mapProps.call(this, {
          ...formProps,
          ...restProps,
        });
        return &lt;WrappedComponent {...props}/&gt;;
      },
    });

    return argumentContainer(Form, WrappedComponent);
  };
}
</code></pre>
<p>可以看出createBaseForm是一个典型的高阶函数，接受options和mixin作为参数，返回一个装饰器decorate函数, 这个decorate函数接受一个react component作为参数，所以我们在外部调用可以使用</p>
<pre><code class="language-js">createForm()(Form);
</code></pre>
<p>这样去获得一个注入了props的组件, 接下来看render中的实现</p>
<pre><code class="language-js">        const formProps = {
          [formPropName]: this.getForm(),
        };
        return &lt;WrappedComponent {...props}/&gt;;
</code></pre>
<p>formPropName在defaultProps中默认被设置为'form', getForm是从mixin中注入的，
其实就相当于注入了</p>
<pre><code class="language-js">{
  form: {
      getFieldsValue: this.fieldsStore.getFieldsValue,
      getFieldValue: this.fieldsStore.getFieldValue,
      getFieldInstance: this.getFieldInstance,
      setFieldsValue: this.setFieldsValue,
      setFields: this.setFields,
      setFieldsInitialValue: this.fieldsStore.setFieldsInitialValue,
      getFieldDecorator: this.getFieldDecorator,
      getFieldProps: this.getFieldProps,
      getFieldsError: this.fieldsStore.getFieldsError,
      getFieldError: this.fieldsStore.getFieldError,
      isFieldValidating: this.fieldsStore.isFieldValidating,
      isFieldsValidating: this.fieldsStore.isFieldsValidating,
      isFieldsTouched: this.fieldsStore.isFieldsTouched,
      isFieldTouched: this.fieldsStore.isFieldTouched,
      isSubmitting: this.isSubmitting,
      submit: this.submit,
      validateFields: this.validateFields,
      resetFields: this.resetFields,
  }
}
</code></pre>
<p>看源码先从主流程看起， 知道了form是如何注入以后，我们就从示例入手， 先看看</p>
<pre><code class="language-js">&lt;input {...getFieldProps('normal')}/&gt;
</code></pre>
<p>中的getFieldProps是如何实现。</p>
<h3>getFieldProps</h3>
<pre><code class="language-js">getFieldProps(name, usersFieldOption = {}) {
        if (!name) {
          throw new Error('Must call `getFieldProps` with valid name string!');
        }
        if (process.env.NODE_ENV !== 'production') {
          warning(
            this.fieldsStore.isValidNestedFieldName(name),
            'One field name cannot be part of another, e.g. `a` and `a.b`.'
          );
          warning(
            !('exclusive' in usersFieldOption),
            '`option.exclusive` of `getFieldProps`|`getFieldDecorator` had been remove.'
          );
        }

        delete this.clearedFieldMetaCache[name];

        const fieldOption = {
          name,
          trigger: DEFAULT_TRIGGER,
          valuePropName: 'value',
          validate: [],
          ...usersFieldOption,
        };

        const {
          rules,
          trigger,
          validateTrigger = trigger,
          validate,
        } = fieldOption;

        const fieldMeta = this.fieldsStore.getFieldMeta(name);
        if ('initialValue' in fieldOption) {
          fieldMeta.initialValue = fieldOption.initialValue;
        }

        const inputProps = {
          ...this.fieldsStore.getFieldValuePropValue(fieldOption),
          ref: this.getCacheBind(name, `${name}__ref`, this.saveRef),
        };
        if (fieldNameProp) {
          inputProps[fieldNameProp] = formName ? `${formName}_${name}` : name;
        }

        const validateRules = normalizeValidateRules(validate, rules, validateTrigger);
        const validateTriggers = getValidateTriggers(validateRules);
        validateTriggers.forEach((action) =&gt; {
          if (inputProps[action]) return;
          inputProps[action] = this.getCacheBind(name, action, this.onCollectValidate);
        });

        // make sure that the value will be collect
        if (trigger &amp;&amp; validateTriggers.indexOf(trigger) === -1) {
          inputProps[trigger] = this.getCacheBind(name, trigger, this.onCollect);
        }

        const meta = {
          ...fieldMeta,
          ...fieldOption,
          validate: validateRules,
        };
        this.fieldsStore.setFieldMeta(name, meta);
        if (fieldMetaProp) {
          inputProps[fieldMetaProp] = meta;
        }

        if (fieldDataProp) {
          inputProps[fieldDataProp] = this.fieldsStore.getField(name);
        }

        return inputProps;
      },
</code></pre>
<p>这个函数接受name，和usersFieldOption两个参数</p>
<pre><code class="language-js">const fieldOption = {
          name,
          trigger: DEFAULT_TRIGGER, // onChange
          valuePropName: 'value',
          validate: [],
          ...usersFieldOption,
};

 const fieldMeta = this.fieldsStore.getFieldMeta(name);
 if ('initialValue' in fieldOption) {
    fieldMeta.initialValue = fieldOption.initialValue;
 }
</code></pre>
<p>先是一波简单的合并配置， 将usersFieldOption混入fiedOption中,
然后从this.fieldsStore中根据name提取出fieldMeta, 将initialValue填入。
fieldsStore是一个存储类，form组件内部有大量的数据需要存储和读取，所以实现了一个fieldsStore类去处理数据的流转。</p>
<pre><code class="language-js">class FieldsStore {
  constructor(fields) {
    this.fields = this.flattenFields(fields);
    this.fieldsMeta = {};
  }
  ...
  getFieldMeta(name) {
    this.fieldsMeta[name] = this.fieldsMeta[name] || {};
    return this.fieldsMeta[name];
  }
}
</code></pre>
<p>因为初始化的this.fieldsStore应该是空的， 所以这里也只是读取到了一个空对象，继续往下走。</p>
<pre><code class="language-js">const inputProps = {
   ...this.fieldsStore.getFieldValuePropValue(fieldOption),
   ref: this.getCacheBind(name, `${name}__ref`, this.saveRef),
};
</code></pre>
<p>inputProps中先是通过fieldsStore实例的getFieldValuePropValue方法传入fieldOption拿到一些属性，
在初始化的时候其实就是{ value: undefined }</p>
<pre><code class="language-js">  getFieldValuePropValue(fieldMeta) {
    // 对应示例中 name: 'normal', valuePropName: 'value'
    const { name, getValueProps, valuePropName } = fieldMeta;
   // 得到 {  name: 'normal'  }， 初始化的时候fields还为空
    const field = this.getField(name);
   // field中没有value， 所以去取initialValue， 示例中未传入，同样为空 
    const fieldValue = 'value' in field ?
      field.value : fieldMeta.initialValue;
    if (getValueProps) {
      return getValueProps(fieldValue);
    }
   // 初始化的时候就返回 { value: undefined }
    return { [valuePropName]: fieldValue };
  }

  getField(name) {
    return {
      ...this.fields[name],
      name,
    };
  }
</code></pre>
<p>ref则是通过this.cacheBind的缓存方法去取缓存了的表单元素ref
此时inputProps = {
value: undefined,
ref: component,
}</p>
<p>接下来是处理有关表单验证的逻辑，</p>
<pre><code class="language-js">const validateRules = normalizeValidateRules(validate, rules, validateTrigger);
const validateTriggers = getValidateTriggers(validateRules);
validateTriggers.forEach((action) =&gt; {
   if (inputProps[action]) return;
   inputProps[action] = this.getCacheBind(name, action, this.onCollectValidate);
});
</code></pre>
<p>normalizeValidateRules方法接受的validate在示例未传入，是空数组，rules是 [{required: true}], validateTrigger是默认的onChange, 看normalizeValidateRules的实现：</p>
<pre><code class="language-js">export function normalizeValidateRules(validate, rules, validateTrigger) {
  const validateRules = validate.map((item) =&gt; {
    const newItem = {
      ...item,
      trigger: item.trigger || [],
    };
    if (typeof newItem.trigger === 'string') {
      newItem.trigger = [newItem.trigger];
    }
    return newItem;
  });
  if (rules) {
    validateRules.push({
      trigger: validateTrigger ? [].concat(validateTrigger) : [],
      rules,
    });
  }
  return validateRules;
}
</code></pre>
<p>我们发现其实返回了</p>
<pre><code class="language-js">validateRules: [{
  trigger: ['onChange'],
  rules: [{required: true}]
}]
</code></pre>
<p>在看getValidateTriggers 将上面的数组传入</p>
<pre><code class="language-js">export function getValidateTriggers(validateRules) {
  return validateRules
    .filter(item =&gt; !!item.rules &amp;&amp; item.rules.length)
    .map(item =&gt; item.trigger)
    .reduce((pre, curr) =&gt; pre.concat(curr), []);
}
</code></pre>
<p>其实就是简单的把rules为空的项过滤掉, 因为每个rule的trigger可能有多个 所以reduce的目的是拉平成一维数组, 最后返回['onChange']这样的数组</p>
<pre><code class="language-js">  validateTriggers = ['onChange']
</code></pre>
<p>最后对validateTriggers进行循环，循环体内</p>
<pre><code class="language-js">if (inputProps[action]) return;
inputProps[action] = this.getCacheBind(name, action, this.onCollectValidate);

</code></pre>
<p>其实就是把onChange: onCollectValidate 这样的校验触发逻辑混入inputProps，关于表单校验的逻辑其实是用了heyiming大大写的async-validator这个库，使用非常广泛，有空的话也可以深入研究一下，可以另开一篇了~</p>
<p>接下来就是合并新的meta对象，并且存入fieldsStore中对应的name存储空间。</p>
<pre><code class="language-js">const meta = {
   ...fieldMeta, // 初始化不存在
   ...fieldOption, // 外部传入和内部默认合并后的options
   validate: validateRules, // 上文已经给出示例中结果
};
this.fieldsStore.setFieldMeta(name, meta);
</code></pre>
<p>setFieldMeta实现就是一个简单的赋值，这样fieldStore内部name这个key就可以读取到存储的数据了。</p>
<pre><code class="language-js"> setFieldMeta(name, meta) {
    this.fieldsMeta[name] = meta;
  }
</code></pre>
<p>最后返回inputProps对象 混入input组件，</p>
<pre><code class="language-js"> return inputProps;

//大概的格式是 
{
   name: 'required',
   onChange(){}, 
   rules: [{required: true}],
}
</code></pre>
<p>示例中的onSubmit函数调用了validateFields,
抛开表单校验的逻辑不看，可以看到这个方法内部这句。</p>
<pre><code class="language-js">if (callback) {
   callback(null, this.fieldsStore.getFieldsValue(fieldNames));
}
</code></pre>
<p>最终整合成{
key: value
}
这样的结果给外部做表单提交。</p>
</div><div class="jsx-1776941920 comments"></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/367088504","query":{},"buildId":"hEKywNj06atDn3wKWx2gf","nextExport":true,"dynamicIds":["+FGM","+fC4","0kiY","1LUk","28xz","2Vkh","3EHr","3gkP","3wag","4Q+X","4qfg","5VxD","5upZ","6ZBy","6k3J","6quq","73oX","75kF","7P7d","7mzT","7oys","8Kqh","8Pgg","8SK+","9Fqr","9G73","9JLW","9Mhc","9Nr/","9Q8I","9U8A","9c9R","9xzc","AIHI","Aayt","Agkw","AhXs","ApBa","Aqyh","AsRY","B05S","BIHe","BKhn","BLBw","BrQc","CyL5","D68y","DxbC","DzyG","E2cJ","EGmf","FIf5","FJ32","G+vv","G01c","GEZ5","GTAt","GgYO","GwJY","Gxxu","H2RM","H4p3","ImXp","JCUK","JGhL","Jb18","Jjkb","JopO","Jrxr","KK3C","KQfT","KUpP","KcjC","Kjk6","KpOm","KyKy","LOdI","LhHj","Ll1m","Lns6","Lo5G","LptB","MF4s","MQ8/","My+Z","NRrW","NyhX","OZ3z","PGlF","PziN","Q5ZB","QPTg","QQjU","QnJG","RLXu","ROUN","Rq6a","SF9x","SLii","Sl5E","T0rU","TdF3","UCcd","UFGb","UI5O","Uasv","VrLj","WSH0","Wj43","WtIr","Xfvt","YROV","YSo5","ZrqW","alHH","beiO","d4EH","ddo8","dnrZ","dycj","e8E9","ebWy","el66","fDA8","fEaW","fHEK","fP8y","fZ2E","gLO8","gmEm","gst6","hmeD","iTGd","ieeH","iobV","irpp","jKVu","jU8F","jW1C","jctj","kZ3Q","lE5/","lKKg","lRCX","lURu","ldBm","m/If","mBTZ","mY11","mzJY","n3/M","nwyE","o0In","oKc0","oU5B","oVRe","oVqn","on2m","ozyK","phP4","pvv5","pw5m","pxCe","qIW7","qUGr","qZUF","r0Rl","r7oX","rfnV","rnof","s8Vx","sM9k","sbla","syIQ","t6qC","tSgA","tluB","u0OR","u2N3","u34i","uIR8","uQpx","uR4j","unZW","vYiF","wB1n","wi1Z","xj1T","yOV0"]}</script><script async="" data-next-page="/367088504" src="/_next/static/hEKywNj06atDn3wKWx2gf/pages/367088504.js"></script><script async="" data-next-page="/_app" src="/_next/static/hEKywNj06atDn3wKWx2gf/pages/_app.js"></script><script async="" src="/_next/static/chunks/22.bfe4263dd9514139326f.js"></script><script src="/_next/static/runtime/webpack-61b9af2a86c3f75f3f39.js" async=""></script><script src="/_next/static/chunks/commons.a1043c35677aeb4954a8.js" async=""></script><script src="/_next/static/runtime/main-7ca00c6bb257c339c190.js" async=""></script></body></html>