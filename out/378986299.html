<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="referrer" content="no-referrer"/><link rel="stylesheet" href="/static/index.css" type="text/css"/><link rel="stylesheet" href="/static/hljs.css" type="text/css"/><link rel="stylesheet" href="/static/reset.css" type="text/css"/><title>ssh的前端博客</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/xOgs5LJb4U_tj9UWKyzRL/pages/378986299.js" as="script"/><link rel="preload" href="/_next/static/xOgs5LJb4U_tj9UWKyzRL/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/chunks/22.bfe4263dd9514139326f.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-61b9af2a86c3f75f3f39.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.d68ea2aa3f883ebc2d53.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-7ca00c6bb257c339c190.js" as="script"/><style id="__jsx-4024170534">.title.jsx-4024170534{margin-top:0;margin-bottom:42px;}.title.jsx-4024170534 a.jsx-4024170534{color:var(--textTitle);-webkit-text-decoration:none;text-decoration:none;}</style><style id="__jsx-2472489444">body{--textTitle:rgb(255,167,196);}</style><style id="__jsx-3985023768">.title.jsx-625829589{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;color:var(--textNormal);}.avatar.jsx-625829589{width:50px;height:50px;border-radius:50%;}</style></head><body><div id="__next"><div style="max-width:672px;margin:auto;padding:42px 21px"><div class="jsx-4024170534"><h2 class="jsx-4024170534 title"><a class="jsx-4024170534" href="/">ssh的前端博客</a></h2></div><div class="jsx-625829589 markdown-body"><h1 class="jsx-625829589 title">Vue源码学习（5）观察属性watch</h1><div><p>上一篇介绍computed的文章讲到了，良好的设计对于功能的实现非常有帮助，computed的核心实现原理是计算watcher，那么watch其实也是基于watcher来实现的，我们还是从initWatch初始化看起。</p>
<h3 id="initwatch">initWatch</h3>
<pre><code class="language-js">function initWatch (vm, watch) {
  for (var key in watch) {
    // 遍历用户定义的watch属性 
    var handler = watch[key];
   // 如果watch是数组 就循环createWatcher
    if (Array.isArray(handler)) {
      for (var i = 0; i &lt; handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      // 否则直接createWatcher
      createWatcher(vm, key, handler);
    }
  }
}</code></pre>
<p>我们可以看到，对于用户定义的单个watch属性，最终vue调用了createWatcher方法</p>
<h3 id="createwatcher">createWatcher</h3>
<pre><code class="language-js">function createWatcher (
  vm,
  expOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === &#39;string&#39;) {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options)
}</code></pre>
<p>这段代码的开头对参数进行了规范化，因为watch是可以支持多种形式的。</p>
<pre><code class="language-js">{
   key: function() {}
}
{
   key: {
      handle: function() {},
      deep: true,
  }
}</code></pre>
<p>最终调用了$watch，第一个参数是要观测的key或者&#39;a.b.c&#39;这样的表达式，handler是用户定义的回调函数，options是{deep: true}这样的watch配置</p>
<pre><code class="language-js"> vm.$watch(expOrFn, handler, options)</code></pre>
<h3 id="watch">$watch</h3>
<p>在vue中以$开头的api一般也提供给用户在外部使用，所以我们在外部也可以通过函数的方式去调用$watch, 比如</p>
<pre><code class="language-js">this.$watch(
  &#39;a&#39;, 
  function() {}, 
  { deep: true }
)</code></pre>
<p>接下来我们来看看$watch的实现</p>
<pre><code class="language-js">Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    // 把options的user属性设为true，让watcher内部使用
    options = options || {};
    options.user = true;
    // 调用Watcher
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };</code></pre>
<p>可以看到， 在把options的user设为true以后，<br>调用了</p>
<pre><code class="language-js">var watcher = new Watcher(vm, expOrFn, cb, options);</code></pre>
<p>我们看看这段函数进入Watcher以后会做什么</p>
<h3 id="watcher">Watcher</h3>
<p>进入了watcher的构造函数以后</p>
<pre><code class="language-js"> if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.computed = !!options.computed;
    this.sync = !!options.sync;
    this.before = options.before;
  }
this.cb = cb;</code></pre>
<p>这个watcher示例的user属性会被设置为true，<br>sync属性也会被设置为用户定义的sync 表示这个watcher的update函数会同步执行。</p>
<pre><code class="language-js">if (typeof expOrFn === &#39;function&#39;) {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(
        &quot;Failed watching path: \&quot;&quot; + expOrFn + &quot;\&quot; &quot; +
        &#39;Watcher only accepts simple dot-delimited paths. &#39; +
        &#39;For full control, use a function instead.&#39;,
        vm
      );
    }
  }</code></pre>
<p>这时候我们的expOrFn应该是个key 或者 &#39;a.b.c&#39;这样的访问路径，所以会进入else逻辑。<br>首先看</p>
<pre><code class="language-js">this.getter = parsePath(expOrFn);</code></pre>
<h3 id="parsepath">parsePath</h3>
<pre><code class="language-js">var bailRE = /[^\w.$]/;
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split(&#39;.&#39;);
  return function (obj) {
    for (var i = 0; i &lt; segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}</code></pre>
<p>我们还是以a.b.c这个路径为例，<br>segments被以.号分隔成[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]这样的数组，<br>然后返回一个函数</p>
<pre><code class="language-js">function (obj) {
    for (var i = 0; i &lt; segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
}</code></pre>
<p>这个函数接受一个对象 然后会依次去访问对象的.a 再去访问.a.b 再去访问.a.b.c，<br>其实这个的目的就是在访问的过程中为这些属性下挂载的dep去收集依赖。</p>
<p>回到我们的watcher的初始化，接下来执行的是</p>
<pre><code class="language-js">if (this.computed) {
    this.value = undefined;
    this.dep = new Dep();
  } else {
    this.value = this.get();
  }</code></pre>
<p>显然我们会走else逻辑，我们继续看this.get()</p>
<h3 id="watcherprototypeget">Watcher.prototype.get</h3>
<pre><code class="language-js">Watcher.prototype.get = function get () {
  // 将全局的Dep.target设置成这个watch属性的watcher
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    // 调用刚刚生成的getter函数，就是parsePath返回的那个函数
    // 这里把vm作为obj传入，所以会依次去读取vm.a vm.a.b vm.a.b.c 并且为这几个元素都收集了依赖。
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, (&quot;getter for watcher \&quot;&quot; + (this.expression) + &quot;\&quot;&quot;));
    } else {
      throw e
    }
  } finally {
    // &quot;touch&quot; every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      // 如果watch的options里设置了deep，就递归的去收集依赖。
      traverse(value);
    }
    // 收集完毕，将Dep.target弹出栈
    popTarget();
    this.cleanupDeps();
  }
  return value
};</code></pre>
<p>至此为止，我们vm下的a a下的b b下的c都收集了这个watcher作为依赖，<br>那么当这些值中的任意值进行改变， 会触发他们内部dep.notify()</p>
<h3 id="depnotify">dep.notify</h3>
<pre><code class="language-js">Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i &lt; l; i++) {
    subs[i].update();
  }
};</code></pre>
<p>subs[i].update()其实就是调用了watcher的update方法，再回到watcher</p>
<h3 id="watcherupdate">watcher.update()</h3>
<pre><code class="language-js">Watcher.prototype.update = function update () {
   // 省略多余逻辑
   if (this.sync) {
    this.run();
   } else {
    queueWatcher(this);
  }
};</code></pre>
<p>这个update是省略掉其他逻辑的，我们之前说过 如果watch的sync设置为true，<br>那么就会直接执行 this.run();</p>
<h3 id="watcherrun">watcher.run</h3>
<pre><code class="language-js">Watcher.prototype.run = function run () {
  if (this.active) {
    this.getAndInvoke(this.cb);
  }
};</code></pre>
<p>这里调用了getAndInvoke(this.cb)，将我们定义的watch回调函数传入</p>
<h3 id="watchergetandinvoke">watcher.getAndInvoke</h3>
<pre><code class="language-js">Watcher.prototype.getAndInvoke = function getAndInvoke (cb) {
  var value = this.get();
  if (
    value !== this.value ||
    isObject(value) ||
    this.deep
  ) {
    if (this.user) {
      try {
        cb.call(this.vm, value, oldValue);
      } catch (e) {
        handleError(e, this.vm, (&quot;callback for watcher \&quot;&quot; + (this.expression) + &quot;\&quot;&quot;));
      }
    }
  }
};</code></pre>
<p>其实就是做了个判断，如果上一次的值和这次的值不相等，或者deep为true，都会直接出发cb.call(this.vm)，并且将新值和旧值传入，这就是我们可以在watch的回调函数里获取新值和旧值的来源。</p>
<p>至此watch函数的实现就分析完毕了，再次感叹一下，良好的设计是成功的开端啊！</p>
</div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/378986299","query":{},"buildId":"xOgs5LJb4U_tj9UWKyzRL","nextExport":true,"dynamicIds":["+FGM","+fC4","0kiY","1LUk","28xz","2Vkh","3EHr","3gkP","3wag","4Q+X","4qfg","5VxD","5upZ","6ZBy","6k3J","6quq","73oX","75kF","7P7d","7mzT","7oys","8Kqh","8Pgg","8SK+","9Fqr","9G73","9JLW","9Mhc","9Nr/","9Q8I","9U8A","9c9R","9xzc","AIHI","Aayt","Agkw","AhXs","ApBa","Aqyh","AsRY","B05S","BIHe","BKhn","BLBw","BrQc","CyL5","D68y","DxbC","DzyG","E2cJ","EGmf","FIf5","FJ32","G+vv","G01c","GEZ5","GTAt","GgYO","GwJY","Gxxu","H2RM","H4p3","ImXp","JCUK","JGhL","Jb18","Jjkb","JopO","Jrxr","KK3C","KQfT","KUpP","KcjC","Kjk6","KpOm","KyKy","LOdI","LhHj","Ll1m","Lns6","Lo5G","LptB","MF4s","MQ8/","My+Z","NRrW","NyhX","OZ3z","PGlF","PziN","Q5ZB","QPTg","QQjU","QnJG","RLXu","ROUN","Rq6a","SF9x","SLii","Sl5E","T0rU","TdF3","UCcd","UFGb","UI5O","Uasv","VrLj","WSH0","Wj43","WtIr","Xfvt","YROV","YSo5","ZrqW","alHH","beiO","d4EH","ddo8","dnrZ","dycj","e8E9","ebWy","el66","fDA8","fEaW","fHEK","fP8y","fZ2E","gLO8","gmEm","gst6","hmeD","iTGd","ieeH","iobV","irpp","jKVu","jU8F","jW1C","jctj","kZ3Q","lE5/","lKKg","lRCX","lURu","ldBm","m/If","mBTZ","mY11","mzJY","n3/M","nwyE","o0In","oKc0","oU5B","oVRe","oVqn","on2m","ozyK","phP4","pvv5","pw5m","pxCe","qIW7","qUGr","qZUF","r0Rl","r7oX","rfnV","rnof","s8Vx","sM9k","sbla","syIQ","t6qC","tSgA","tluB","u0OR","u2N3","u34i","uIR8","uQpx","uR4j","unZW","vYiF","wB1n","wi1Z","xj1T","yOV0"]}</script><script async="" data-next-page="/378986299" src="/_next/static/xOgs5LJb4U_tj9UWKyzRL/pages/378986299.js"></script><script async="" data-next-page="/_app" src="/_next/static/xOgs5LJb4U_tj9UWKyzRL/pages/_app.js"></script><script async="" src="/_next/static/chunks/22.bfe4263dd9514139326f.js"></script><script src="/_next/static/runtime/webpack-61b9af2a86c3f75f3f39.js" async=""></script><script src="/_next/static/chunks/commons.d68ea2aa3f883ebc2d53.js" async=""></script><script src="/_next/static/runtime/main-7ca00c6bb257c339c190.js" async=""></script></body></html>