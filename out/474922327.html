<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="referrer" content="no-referrer"/><link rel="stylesheet" href="/static/index.css" type="text/css"/><link rel="stylesheet" href="/static/hljs.css" type="text/css"/><link rel="stylesheet" href="/static/reset.css" type="text/css"/><link rel="stylesheet" href="/static/markdown.css" type="text/css"/><title>ssh的前端博客</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/sRx8BjZglL9PSHp0plaZ3/pages/474922327.js" as="script"/><link rel="preload" href="/_next/static/sRx8BjZglL9PSHp0plaZ3/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/chunks/22.bfe4263dd9514139326f.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-61b9af2a86c3f75f3f39.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.80342d5a09c6f0ef20e1.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-7ca00c6bb257c339c190.js" as="script"/><style id="__jsx-4024170534">.title.jsx-4024170534{margin-top:0;margin-bottom:42px;}.title.jsx-4024170534 a.jsx-4024170534{color:var(--textTitle);-webkit-text-decoration:none;text-decoration:none;}</style><style id="__jsx-2472489444">body{--textTitle:rgb(255,167,196);}</style><style id="__jsx-4063293197">.title.jsx-1776941920{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;color:var(--textNormal);}.avatar.jsx-1776941920{width:50px;height:50px;border-radius:50%;}.comment.jsx-1776941920{margin-bottom:32px;border-bottom:1px solid #eee;}.user.jsx-1776941920{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.login.jsx-1776941920{color:var(--textLink);-webkit-text-decoration:none;text-decoration:none;}.avatar.jsx-1776941920{width:32px;height:32px;border-radius:50%;margin-right:8px;}</style></head><body><div id="__next"><div style="max-width:672px;margin:auto;padding:42px 21px"><div class="jsx-4024170534"><h2 class="jsx-4024170534 title"><a class="jsx-4024170534" href="/">ssh<!-- -->的前端博客</a></h2></div><div class="jsx-1776941920 markdown-body"><h1 class="jsx-1776941920 title">用jsx封装Vue中的复杂组件（网易云音乐实战项目需求）</h1><div><h2>背景介绍</h2>
<p>最近在做vue高仿<a href="https://juejin.im/post/5d3c0765f265da1b60294b78">网易云音乐</a>的项目，在做的过程中发现音乐表格这个组件会被非常多的地方复用，而且需求比较复杂的和灵活。</p>
<h3><a href="http://47.99.213.231:8001/">预览地址</a></h3>
<h3><a href="https://github.com/sl1673495/vue-netease-music">源码地址</a></h3>
<h2>图片预览</h2>
<ul>
<li>歌单详情
<img src="https://user-gold-cdn.xitu.io/2019/7/31/16c45d24774d06bf?w=1209&amp;h=481&amp;f=png&amp;s=154844" alt="歌单详情"></li>
<li>播放列表
<img src="https://user-gold-cdn.xitu.io/2019/7/31/16c45d2920dc1634?w=391&amp;h=358&amp;f=png&amp;s=53326" alt="播放列表"></li>
<li>搜索高亮
<img src="https://user-gold-cdn.xitu.io/2019/7/31/16c46085f7a4c70c?w=1210&amp;h=363&amp;f=png&amp;s=135056" alt="搜索高亮"></li>
</ul>
<h2>需求分析</h2>
<p>它需要支持：</p>
<ul>
<li>
<p>hideColumns参数， 自定义需要隐藏哪些列。</p>
</li>
<li>
<p>highLightText，传入字符串，数据中命中的字符串高亮。</p>
</li>
</ul>
<p>首先 看一下我们平常的table写法。</p>
<pre><code class="language-javascript">  &lt;el-table
      :data=&quot;tableData&quot;
      style=&quot;width: 100%&quot;&gt;
      &lt;el-table-column
        prop=&quot;index&quot;
        label=&quot; &quot;
        width=&quot;180&quot;&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column
        prop=&quot;name&quot;
        label=&quot;音乐标题&quot;
        width=&quot;180&quot;&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column
        prop=&quot;artistsText&quot;
        label=&quot;歌手&quot;&gt;
      &lt;/el-table-column&gt;
    &lt;/el-table&gt;
</code></pre>
<p>这是官网的写法，假设我们传入了 hideColumns: ['index', 'name']，我们需要在模板里隐藏的话```</p>
<pre><code class="language-javascript">  &lt;el-table
    :data=&quot;tableData&quot;
    style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column
  +++ v-if=&quot;!hideColumns.includes('index')&quot;
      prop=&quot;index&quot;
      label=&quot; &quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
  +++ v-if=&quot;!hideColumns.includes('name')&quot;
      prop=&quot;name&quot;
      label=&quot;音乐标题&quot;
      width=&quot;180&quot;&gt;
    &lt;/el-table-column&gt;
    &lt;el-table-column
  +++ v-if=&quot;!hideColumns.includes('address')&quot;
      prop=&quot;artistsText&quot;
      label=&quot;歌手&quot;&gt;
    &lt;/el-table-column&gt;
  &lt;/el-table&gt;
</code></pre>
<p>这种代码非常笨，所以我们肯定是接受不了的，我们很自然的联想到平常用v-for循环，能不能套用在这个需求上呢。
首先在data里定义columns</p>
<pre><code class="language-javascript">data() {
    return {
      columns: [{
        prop: 'index',
        label: '',
        width: '50'
      }, {
        prop: 'artistsText',
        label: '歌手'
      }, {
        prop: 'albumName',
        label: '专辑'
      }, {
        prop: 'durationSecond',
        label: '时长',
        width: '100',
      }]
    }
}
</code></pre>
<p>然后我们在computed中计算hideColumns做一次合并</p>
<pre><code class="language-javascript">  computed: {
    showColumns() {
      const { hideColumns } = this
      return this.columns.filter(column =&gt; {
        return !this.hideColumns.find((prop) =&gt; prop === column.prop)
      })
    },
  },
</code></pre>
<p>那么模板里我们就可以简写成</p>
<pre><code class="language-javascript">&lt;el-table
    :data=&quot;songs&quot;
  &gt;
    &lt;template v-for=&quot;(column, index) in showColumns&quot;&gt;
      &lt;el-table-column
        :key=&quot;index&quot;
        // 混入属性
        v-bind=&quot;column&quot;
      &gt;
      &lt;/el-table-column&gt;
    &lt;/template&gt;
  &lt;/el-table&gt;
</code></pre>
<p>注意<code> v-bind=&quot;column&quot;</code>这行， 相当于把column中的所有属性混入到table-column中去，是一个非常简便的方法。</p>
<h2>script配合template的解决方案</h2>
<p>这样需求看似解决了，很美好。
</br>
但是我们忘了非常重要的一点，<code>slotScopes</code>这个东西！</p>
<p>比如音乐时长我们需要format一下，</p>
<pre><code class="language-javascript"> &lt;el-table-column&gt;
     &lt;template&gt;
        &lt;span&gt;{{ $utils.formatTime(scope.row.durationSecond) }}&lt;/span&gt;
     &lt;/template&gt;
 &lt;/el-table-column&gt;
</code></pre>
<p>但是我们现在把columns都写到script里了，和template分离开来了，我暂时还不知道有什么方法能把<code>sciprt</code>里写的模板放到<code>template</code>里用，所以先想到一个可以解决问题的方法。就是在template里加一些判断。</p>
<pre><code class="language-javascript">&lt;el-table
    v-bind=&quot;$attrs&quot;
    v-if=&quot;songs.length&quot;
    :data=&quot;songs&quot;
    @row-click=&quot;onRowClick&quot;
    :cell-class-name=&quot;tableCellClassName&quot;
    style=&quot;width: 99.9%&quot;
  &gt;
    &lt;template v-for=&quot;(column, index) in showColumns&quot;&gt;
      &lt;!-- 需要自定义渲染的列 --&gt;
      &lt;el-table-column
        v-if=&quot;['durationSecond'].includes(column.prop)&quot;
        :key=&quot;index&quot;
        v-bind=&quot;column&quot;
      &gt;
          &lt;!-- 时长 --&gt;
          &lt;template v-else-if=&quot;column.prop === 'durationSecond'&quot;&gt;
            &lt;span&gt;{{ $utils.formatTime(scope.row.durationSecond) }}&lt;/span&gt;
          &lt;/template&gt;
      &lt;/el-table-column&gt;

      &lt;!-- 普通列 --&gt;
      &lt;el-table-column
        v-else
        :key=&quot;index&quot;
        v-bind=&quot;column&quot;
      &gt;
      &lt;/el-table-column&gt;
    &lt;/template&gt;
  &lt;/el-table&gt;
</code></pre>
<p>又一次的需求看似解决了，很美好。</p>
<h2>高亮文字匹配需求分析</h2>
</br>
但是新需求又来了！！根据传入的 highLightText 去高亮某些文字，我们分析一下需求
</br>
<p><code>鸡你太美</code>这个歌名，我们在搜索框输入<code>鸡你</code>
我们需要把</p>
<pre><code>&lt;span&gt;鸡你太美&lt;/span&gt;
</code></pre>
<p>转化为</p>
<pre><code>  &lt;span&gt;
    &lt;span class=&quot;high-light&quot;&gt;鸡你&lt;/span&gt;
    太美
 &lt;/span&gt;
</code></pre>
<p>我们在template里找到音乐标题这行，写下这端代码：</p>
<pre><code class="language-javascript">&lt;template v-else-if=&quot;column.prop === 'name'&quot;&gt;
  &lt;span&gt;{{this.genHighlight(scope.row.name)}}&lt;/span&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="language-javascript">methods: {
    genHighlight(text) {
       return &lt;span&gt;xxx&lt;/span&gt;
    }
}
</code></pre>
<p>我发现无从下手了, 因为jsx最终编译成的是return vnode的方法，genHighlight执行以后返回的是vnode，但是你不能直接把vnode放到template里去。</p>
<h2>jsx终极解决方案</h2>
<p>所以我们要统一环境，直接使用jsx渲染我们的组件，文档可以参照
</br>
<a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx">babel-plugin-transform-vue-jsx</a>
<br>
<a href="https://github.com/vuejs/jsx">vuejs/jsx</a></p>
<pre><code class="language-javascript">import ElTable from 'element-ui/lib/table'

data() {
    const commonHighLightSlotScopes = {
      scopedSlots: {
        default: (scope) =&gt; {
          return (
            &lt;span&gt;{this.genHighlight(scope.row[scope.column.property])}&lt;/span&gt;
          )
        }
      }
    }
    return {
      columns: [{
        prop: 'name',
        label: '音乐标题',
        ...commonHighLightSlotScopes
      }, {
        prop: 'artistsText',
        label: '歌手',
         ...commonHighLightSlotScopes
      }, {
        prop: 'albumName',
        label: '专辑',
        ...commonHighLightSlotScopes
      }, {
        prop: 'durationSecond',
        label: '时长',
        width: '100',
        scopedSlots: {
          default: (scope) =&gt; {
            return (
              &lt;span&gt;{this.$utils.formatTime(scope.row.durationSecond)}&lt;/span&gt;
            )
          }
        }
      }]
    }
  },
  methods: {
    genHighlight(title = '') {
      ...省去一些细节
      const titleSpan = matchIndex &gt; -1 ? (
        &lt;span&gt;
          {beforeStr}
          &lt;span class=&quot;high-light-text&quot;&gt;{hitStr}&lt;/span&gt;
          {afterStr}
        &lt;/span&gt;
      ) : title;
      return titleSpan;
    },
  },
 render() {
    const elTableProps = ElTable.props
    // 从$attrs里提取作为prop的值
    // 这里要注意的点是驼峰命名法(camelCase)和短横线命名法(kebab-case)
    // 都是可以被组件接受的，虽然elTable里的prop定义的属性叫cellClassName
    // 但是我们要把cell-class-name也解析进prop里
    const { props, attrs } = genPropsAndAttrs(this.$attrs, elTableProps)
    
    const tableAttrs = {
      attrs,
      on: {
        ...this.$listeners,
        ['row-click']: this.onRowClick,
      },
      props: {
        ...props,
        cellClassName: this.tableCellClassName,
        data: this.songs,
      },
      style: { width: '99.9%' }
    }
    return this.songs.length ? (
      &lt;el-table
        {...tableAttrs}
      &gt;
        {this.showColumns.map((column, index) =&gt; {
          const { scopedSlots, ...columnProps } = column
          return (
            &lt;el-table-column key={index} props={columnProps} scopedSlots={scopedSlots} &gt;
            &lt;/el-table-column&gt;
          )
        })}
      &lt;/el-table&gt;
    ) : null
  }
</code></pre>
<p><code>attrs: this.$attrs</code> 注意这句话，我们在template里可以通过
<code>v-bind=&quot;$attrs&quot;</code>去透传外部传进来的所有属性，<br>
但是在jsx中我们必须分类清楚传给el-table的<code>attrs</code>和<code>props</code><br>
比如el-table接受<code>data</code>这个prop，如果你放在attrs里传进去，那么就失效了。</p>
<p>这个我暂时也没找到特别好的解决方法，只能先引用去拿elTable上的props去进行比对$attrs，取交集。</p>
<pre><code class="language-javascript">import ElTable from 'element-ui/lib/table'
// 从$attrs里提取作为prop的值
// 这里要注意的点是驼峰命名法(camelCase)和短横线命名法(kebab-case)
// 都是可以被组件接受的，虽然elTable里的prop定义的属性叫cellClassName
// 但是我们要把cell-class-name也解析进prop里
const { props, attrs } = genPropsAndAttrs(this.$attrs, elTableProps)
</code></pre>
<p>可以看到代码中模板的部分少了很多重复的判断，维护性和扩展性都更强了，jsx可以说是复杂组件的终极解决方案，但是要真正的封装好一个高阶组件，要做的还非常多。</p>
</div><div class="jsx-1776941920 comments"></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/474922327","query":{},"buildId":"sRx8BjZglL9PSHp0plaZ3","nextExport":true,"dynamicIds":["+FGM","+fC4","0kiY","1LUk","28xz","2Vkh","3EHr","3gkP","3wag","4Q+X","4qfg","5VxD","5upZ","6ZBy","6k3J","6quq","73oX","75kF","7P7d","7mzT","7oys","8Kqh","8Pgg","8SK+","9Fqr","9G73","9JLW","9Mhc","9Nr/","9Q8I","9U8A","9c9R","9xzc","AIHI","Aayt","Agkw","AhXs","ApBa","Aqyh","AsRY","B05S","BIHe","BKhn","BLBw","BrQc","CyL5","D68y","DxbC","DzyG","E2cJ","EGmf","FIf5","FJ32","G+vv","G01c","GEZ5","GTAt","GgYO","GwJY","Gxxu","H2RM","H4p3","ImXp","JCUK","JGhL","Jb18","Jjkb","JopO","Jrxr","KK3C","KQfT","KUpP","KcjC","Kjk6","KpOm","KyKy","LOdI","LhHj","Ll1m","Lns6","Lo5G","LptB","MF4s","MQ8/","My+Z","NRrW","NyhX","OZ3z","PGlF","PziN","Q5ZB","QPTg","QQjU","QnJG","RLXu","ROUN","Rq6a","SF9x","SLii","Sl5E","T0rU","TdF3","UCcd","UFGb","UI5O","Uasv","VrLj","WSH0","Wj43","WtIr","Xfvt","YROV","YSo5","ZrqW","alHH","beiO","d4EH","ddo8","dnrZ","dycj","e8E9","ebWy","el66","fDA8","fEaW","fHEK","fP8y","fZ2E","gLO8","gmEm","gst6","hmeD","iTGd","ieeH","iobV","irpp","jKVu","jU8F","jW1C","jctj","kZ3Q","lE5/","lKKg","lRCX","lURu","ldBm","m/If","mBTZ","mY11","mzJY","n3/M","nwyE","o0In","oKc0","oU5B","oVRe","oVqn","on2m","ozyK","phP4","pvv5","pw5m","pxCe","qIW7","qUGr","qZUF","r0Rl","r7oX","rfnV","rnof","s8Vx","sM9k","sbla","syIQ","t6qC","tSgA","tluB","u0OR","u2N3","u34i","uIR8","uQpx","uR4j","unZW","vYiF","wB1n","wi1Z","xj1T","yOV0"]}</script><script async="" data-next-page="/474922327" src="/_next/static/sRx8BjZglL9PSHp0plaZ3/pages/474922327.js"></script><script async="" data-next-page="/_app" src="/_next/static/sRx8BjZglL9PSHp0plaZ3/pages/_app.js"></script><script async="" src="/_next/static/chunks/22.bfe4263dd9514139326f.js"></script><script src="/_next/static/runtime/webpack-61b9af2a86c3f75f3f39.js" async=""></script><script src="/_next/static/chunks/commons.80342d5a09c6f0ef20e1.js" async=""></script><script src="/_next/static/runtime/main-7ca00c6bb257c339c190.js" async=""></script></body></html>