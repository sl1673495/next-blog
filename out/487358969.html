<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="referrer" content="no-referrer"/><link rel="stylesheet" href="/static/index.css" type="text/css"/><link rel="stylesheet" href="/static/hljs.css" type="text/css"/><link rel="stylesheet" href="/static/reset.css" type="text/css"/><title>ssh的前端博客</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/xOgs5LJb4U_tj9UWKyzRL/pages/487358969.js" as="script"/><link rel="preload" href="/_next/static/xOgs5LJb4U_tj9UWKyzRL/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/chunks/22.bfe4263dd9514139326f.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-61b9af2a86c3f75f3f39.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.d68ea2aa3f883ebc2d53.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-7ca00c6bb257c339c190.js" as="script"/><style id="__jsx-4024170534">.title.jsx-4024170534{margin-top:0;margin-bottom:42px;}.title.jsx-4024170534 a.jsx-4024170534{color:var(--textTitle);-webkit-text-decoration:none;text-decoration:none;}</style><style id="__jsx-2472489444">body{--textTitle:rgb(255,167,196);}</style><style id="__jsx-3985023768">.title.jsx-625829589{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;color:var(--textNormal);}.avatar.jsx-625829589{width:50px;height:50px;border-radius:50%;}</style></head><body><div id="__next"><div style="max-width:672px;margin:auto;padding:42px 21px"><div class="jsx-4024170534"><h2 class="jsx-4024170534 title"><a class="jsx-4024170534" href="/">ssh的前端博客</a></h2></div><div class="jsx-625829589 markdown-body"><h1 class="jsx-625829589 title">使用React Hooks + 自定义Hook封装一步一步打造一个完善的小型应用。</h1><div><h2 id="前言">前言</h2>
<p>Reack Hooks自从16.8发布以来，社区已经有相当多的讨论和应用了，不知道各位在公司里有没有用上这个酷炫的特性~  </p>
<p>今天分享一下利用React Hooks实现一个功能相对完善的todolist。  </p>
<p>特点：</p>
<ul>
<li>利用自定义hook管理请求</li>
<li>利用hooks做代码组织和逻辑分离</li>
</ul>
<h2 id="界面预览">界面预览</h2>
<p><img src="https://user-images.githubusercontent.com/23615778/64005966-ee228d80-cb43-11e9-8c59-f494c8b52a6b.png" alt="预览"></p>
<h2 id="体验地址">体验地址</h2>
<p><a href="https://codesandbox.io/s/react-hooks-todo-dh3gx?fontsize=14">https://codesandbox.io/s/react-hooks-todo-dh3gx?fontsize=14</a></p>
<h2 id="代码详解">代码详解</h2>
<h3 id="界面">界面</h3>
<p>首先我们引入antd作为ui库，节省掉无关的一些逻辑，快速的构建出我们的页面骨架</p>
<pre><code class="language-js">
const TAB_ALL = &quot;all&quot;;
const TAB_FINISHED = &quot;finished&quot;;
const TAB_UNFINISHED = &quot;unfinished&quot;;
const tabMap = {
  [TAB_ALL]: &quot;全部&quot;,
  [TAB_FINISHED]: &quot;已完成&quot;,
  [TAB_UNFINISHED]: &quot;待完成&quot;
};

function App() {
  const [activeTab, setActiveTab] = useState(TAB_ALL);

  return (
    &lt;&gt;
      &lt;Tabs activeKey={activeTab} onChange={setActiveTab}&gt;
        &lt;TabPane tab={tabMap[TAB_ALL]} key={TAB_ALL} /&gt;
        &lt;TabPane tab={tabMap[TAB_FINISHED]} key={TAB_FINISHED} /&gt;
        &lt;TabPane tab={tabMap[TAB_UNFINISHED]} key={TAB_UNFINISHED} /&gt;
      &lt;/Tabs&gt;
      &lt;div className=&quot;app-wrap&quot;&gt;
        &lt;h1 className=&quot;app-title&quot;&gt;Todo List&lt;/h1&gt;
        &lt;Input /&gt;
        &lt;TodoList /&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}</code></pre>
<h3 id="数据获取">数据获取</h3>
<p>有了界面以后，接下来就要获取数据。</p>
<h4 id="模拟api">模拟api</h4>
<p>这里我新建了一个api.js专门用来模拟接口获取数据，这里面的逻辑大概看一下就好，不需要特别在意。</p>
<pre><code class="language-js">const todos = [
  {
    id: 1,
    text: &quot;todo1&quot;,
    finished: true
  },
  {
    id: 2,
    text: &quot;todo2&quot;,
    finished: false
  },
  {
    id: 3,
    text: &quot;todo3&quot;,
    finished: true
  },
  {
    id: 4,
    text: &quot;todo4&quot;,
    finished: false
  },
  {
    id: 5,
    text: &quot;todo5&quot;,
    finished: false
  }
];

const delay = time =&gt; new Promise(resolve =&gt; setTimeout(resolve, time));
// 将方法延迟1秒
const withDelay = fn =&gt; async (...args) =&gt; {
  await delay(1000);
  return fn(...args);
};

// 获取todos
export const fetchTodos = withDelay(params =&gt; {
  const { query, tab } = params;
  let result = todos;
  // tab页分类
  if (tab) {
    switch (tab) {
      case &quot;finished&quot;:
        result = result.filter(todo =&gt; todo.finished === true);
        break;
      case &quot;unfinished&quot;:
        result = result.filter(todo =&gt; todo.finished === false);
        break;
      default:
        break;
    }
  }

  // 带参数查询
  if (query) {
    result = result.filter(todo =&gt; todo.text.includes(query));
  }

  return Promise.resolve({
    tab,
    result
  });
});</code></pre>
<p>这里我们封装了个withDelay方法用来包裹函数，模拟异步请求接口的延迟，这样方便我们后面演示loading功能。</p>
<h4 id="基础数据获取">基础数据获取</h4>
<p>获取数据，最传统的方式就是在组件中利用useEffect来完成请求，并且声明依赖值来在某些条件改变后重新获取数据，简单写一个：</p>
<pre><code class="language-js">import { fetchTodos } from &#39;./api&#39;

const TAB_ALL = &quot;all&quot;;
const TAB_FINISHED = &quot;finished&quot;;
const TAB_UNFINISHED = &quot;unfinished&quot;;
const tabMap = {
  [TAB_ALL]: &quot;全部&quot;,
  [TAB_FINISHED]: &quot;已完成&quot;,
  [TAB_UNFINISHED]: &quot;待完成&quot;
};

function App() {
  const [activeTab, setActiveTab] = useState(TAB_ALL);


  // 获取数据
  const [loading, setLoading] = useState(false)
  const [todos, setTodos] = useState([])
  useEffect(() =&gt; {
    setLoading(true)
    fetchTodos({tab: activeTab})
        .then(result =&gt; {
            setTodos(todos)
        })
        .finally(() =&gt; {
            setLoading(false)
        })
  }, [])


  return (
    &lt;&gt;
      &lt;Tabs activeKey={activeTab} onChange={setActiveTab}&gt;
        &lt;TabPane tab={tabMap[TAB_ALL]} key={TAB_ALL} /&gt;
        &lt;TabPane tab={tabMap[TAB_FINISHED]} key={TAB_FINISHED} /&gt;
        &lt;TabPane tab={tabMap[TAB_UNFINISHED]} key={TAB_UNFINISHED} /&gt;
      &lt;/Tabs&gt;
      &lt;div className=&quot;app-wrap&quot;&gt;
        &lt;h1 className=&quot;app-title&quot;&gt;Todo List&lt;/h1&gt;
        &lt;Input /&gt;
        &lt;Spin spinning={loading} tip=&quot;稍等片刻~&quot;&gt;
          &lt;!--把todos传递给组件--&gt;
          &lt;TodoList todos={todos}/&gt;
        &lt;/Spin&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}</code></pre>
<p>这样很好，在公司内部新启动的项目里我的同事们也都是这么写的，但是这样的获取数据有几个小问题。</p>
<ul>
<li>每次都要用useState建立loading的的状态</li>
<li>每次都要用useState建立请求结果的状态</li>
<li>对于请求如果有一些更高阶的封装的话，不太好操作。  </li>
</ul>
<p>所以这里要封装一个专门用于请求的自定义hook。  </p>
<h3 id="自定义hook（数据获取）">自定义hook（数据获取）</h3>
<p>忘了在哪看到的说法，自定hook其实就是把useXXX方法执行以后，把方法体里的内容平铺到组件内部，我觉得这种说法对于理解自定义hook很友好。</p>
<pre><code class="language-js">useTest() {
    const [test, setTest] = useState(&#39;&#39;)
    setInterval(() =&gt; {
        setTest(Math.random())
    }, 1000)
    return {test, setTest}
}

function App() {
    const {test, setTest} = useTest()

    return &lt;span&gt;{test}&lt;/span&gt;
}
</code></pre>
<p>这段代码等价于：</p>
<pre><code class="language-js">function App() {
    const [test, setTest] = useState(&#39;&#39;)
    setInterval(() =&gt; {
        setTest(Math.random())
    }, 1000)

    return &lt;span&gt;{test}&lt;/span&gt;
}
</code></pre>
<p>是不是瞬间感觉自定hook很简单了~ 基于这个思路，我们来封装一下我们需要的useRequest方法。</p>
<pre><code>export const useRequest = (fn, dependencies) =&gt; {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);

  // 请求的方法 这个方法会自动管理loading
  const request = () =&gt; {
    setLoading(true);
    fn()
      .then(setData)
      .finally(() =&gt; {
        setLoading(false);
      });
  };

  // 根据传入的依赖项来执行请求
  useEffect(() =&gt; {
    request()
  }, dependencies);

  return {
      // 请求获取的数据
      data,
      // loading状态
      loading,
      // 请求的方法封装
      request
  };
};</code></pre><p>有了这个自定义hook，我们组件内部的代码又可以精简很多。</p>
<pre><code class="language-js">import { fetchTodos } from &#39;./api&#39;
import { useRequest } from &#39;./hooks&#39;

const TAB_ALL = &quot;all&quot;;
const TAB_FINISHED = &quot;finished&quot;;
const TAB_UNFINISHED = &quot;unfinished&quot;;
const tabMap = {
  [TAB_ALL]: &quot;全部&quot;,
  [TAB_FINISHED]: &quot;已完成&quot;,
  [TAB_UNFINISHED]: &quot;待完成&quot;
};

function App() {
  const [activeTab, setActiveTab] = useState(TAB_ALL);

  // 获取数据
  const {loading, data: todos} = useRequest(() =&gt; {
      return fetchTodos({ tab: activeTab });
  }, [activeTab]) 

  return (
    &lt;&gt;
      &lt;Tabs activeKey={activeTab} onChange={setActiveTab}&gt;
        &lt;TabPane tab={tabMap[TAB_ALL]} key={TAB_ALL} /&gt;
        &lt;TabPane tab={tabMap[TAB_FINISHED]} key={TAB_FINISHED} /&gt;
        &lt;TabPane tab={tabMap[TAB_UNFINISHED]} key={TAB_UNFINISHED} /&gt;
      &lt;/Tabs&gt;
      &lt;div className=&quot;app-wrap&quot;&gt;
        &lt;h1 className=&quot;app-title&quot;&gt;Todo List&lt;/h1&gt;
        &lt;Input /&gt;
        &lt;Spin spinning={loading} tip=&quot;稍等片刻~&quot;&gt;
          &lt;!--把todos传递给组件--&gt;
          &lt;TodoList todos={todos}/&gt;
        &lt;/Spin&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}</code></pre>
<p>果然，样板代码少了很多，腰不酸了腿也不痛了，一口气能发5个请求了！</p>
<h4 id="消除tab频繁切换产生的脏数据">消除tab频繁切换产生的脏数据</h4>
<p>在真实开发中我们特别容易遇到的一个场景就是，tab切换并不改变视图，而是去重新请求新的列表数据，在这种情况下我们可能就会遇到一个问题，以这个todolist举例，我们从<code>全部</code>tab切换到<code>已完成</code>tab，会去请求数据，但是如果我们在<code>已完成</code>tab的数据还没请求完成时，就去点击<code>待完成</code>的tab页，这时候就要考虑一个问题，异步请求的响应时间是不确定的，很可能我们发起的第一个请求<code>已完成</code>最终耗时5s，第二个请求<code>待完成</code>最终耗时1s，这样第二个请求的数据返回，渲染完页面以后，过了几秒第一个请求的数据返回了，但是这个时候我们的tab是停留在对应第二个请求<code>待完成</code>上，这就造成了脏数据的bug。</p>
<p>这个问题其实我们可以利用useEffect的特性在useRequest封装解决。</p>
<pre><code class="language-js">
export const useRequest = (fn, dependencies, defaultValue = []) =&gt; {
  const [data, setData] = useState(defaultValue);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(false);

  const request = () =&gt; {
    // 定义cancel标志位
    let cancel = false;
    setLoading(true);
    fn()
      .then(res =&gt; {
        if (!cancel) {
          setData(res);
        } else {
          // 在请求成功取消掉后，打印测试文本。
          const { tab } = res;
          console.log(`request with ${tab} canceled`);
        }
      })
      .catch(() =&gt; {
        if (!cancel) {
          setError(error);
        }
      })
      .finally(() =&gt; {
        if (!cancel) {
          setLoading(false);
        }
      });

    // 请求的方法返回一个 取消掉这次请求的方法
    return () =&gt; {
      cancel = true;
    };
  };

  // 重点看这段，在useEffect传入的函数，返回一个取消请求的函数
  // 这样在下一次调用这个useEffect时，会先取消掉上一次的请求。
  useEffect(() =&gt; {
    const cancelRequest = request();
    return () =&gt; {
      cancelRequest();
    };
    // eslint-disable-next-line
  }, dependencies);

  return { data, setData, loading, error, request };
};</code></pre>
<p>其实这里request里实现的取消请求只是我们模拟出来的取消，真实情况下可以利用axios等请求库提供的方法做不一样的封装，这里主要是讲思路。<br>useEffect里返回的函数其实叫做清理函数，在每次新一次执行useEffect时，都会先执行清理函数，我们利用这个特性，就能成功的让useEffect永远只会用最新的请求结果去渲染页面。</p>
<p>可以去<a href="https://codesandbox.io/s/react-hooks-todo-dh3gx?fontsize=14">预览地址</a>快速点击tab页切换，看一下控制台打印的结果。</p>
<h3 id="主动请求的封装">主动请求的封装</h3>
<p>现在需要加入一个功能，点击列表中的项目，切换完成状态，这时候<code>useRequest</code>好像就不太合适了，因为<code>useRequest</code>其实本质上是针对useEffect的封装，而useEffect的使用场景是初始化和依赖变更的时候发起请求，但是这个新需求其实是响应用户的点击而去主动发起请求，难道我们又要手动写setLoading之类的冗余代码了吗？答案当然是不。<br>我们利用高阶函数的思想封装一个自定义hook：<code>useWithLoading</code></p>
<h4 id="usewithloading代码实现">useWithLoading代码实现</h4>
<pre><code class="language-js">export function useWithLoading(fn) {
  const [loading, setLoading] = useState(false);

  const func = (...args) =&gt; {
    setLoading(true);
    return fn(...args).finally(() =&gt; {
      setLoading(false);
    });
  };

  return { func, loading };
}</code></pre>
<p>它本质上就是对传入的方法进行了一层包裹，在执行前后去更改loading状态。<br>使用：</p>
<pre><code class="language-js"> // 完成todo逻辑
  const { func: onToggleFinished, loading: toggleLoading } = useWithLoading(
    async id =&gt; {
      await toggleTodo(id);
    }
  );

&lt;TodoList todos={todos} onToggleFinished={onToggleFinished} /&gt;
</code></pre>
<h3 id="代码组织">代码组织</h3>
<p>加入一个新功能，input的placeholder根据tab页的切换去切换文案，注意，这里我们先提供一个错误的示例，这是刚从Vue2.x和React Class Component转过来的人很容易犯的一个错误。</p>
<p>❌错误示例</p>
<pre><code class="language-js">import { fetchTodos } from &#39;./api&#39;
import { useRequest } from &#39;./hooks&#39;

const TAB_ALL = &quot;all&quot;;
const TAB_FINISHED = &quot;finished&quot;;
const TAB_UNFINISHED = &quot;unfinished&quot;;
const tabMap = {
  [TAB_ALL]: &quot;全部&quot;,
  [TAB_FINISHED]: &quot;已完成&quot;,
  [TAB_UNFINISHED]: &quot;待完成&quot;
};

function App() {
  // state放在一起
  const [activeTab, setActiveTab] = useState(TAB_ALL);
  const [placeholder, setPlaceholder] = useState(&quot;&quot;);
  const [query, setQuery] = useState(&quot;&quot;);

  // 副作用放在一起
  const {loading, data: todos} = useRequest(() =&gt; {
      return fetchTodos({ tab: activeTab });
  }, [activeTab]) 
  useEffect(() =&gt; {
    setPlaceholder(`在${tabMap[activeTab]}内搜索`);
  }, [activeTab]);
  const { func: onToggleFinished, loading: toggleLoading } = useWithLoading(
    async id =&gt; {
      await toggleTodo(id);
    }
  );

  return (
    &lt;&gt;
      &lt;Tabs activeKey={activeTab} onChange={setActiveTab}&gt;
        &lt;TabPane tab={tabMap[TAB_ALL]} key={TAB_ALL} /&gt;
        &lt;TabPane tab={tabMap[TAB_FINISHED]} key={TAB_FINISHED} /&gt;
        &lt;TabPane tab={tabMap[TAB_UNFINISHED]} key={TAB_UNFINISHED} /&gt;
      &lt;/Tabs&gt;
      &lt;div className=&quot;app-wrap&quot;&gt;
        &lt;h1 className=&quot;app-title&quot;&gt;Todo List&lt;/h1&gt;
        &lt;Input /&gt;
        &lt;Spin spinning={loading} tip=&quot;稍等片刻~&quot;&gt;
          &lt;!--把todos传递给组件--&gt;
          &lt;TodoList todos={todos}/&gt;
        &lt;/Spin&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}</code></pre>
<p>注意，在之前的vue和react开发中，因为vue代码组织的方式都是 <code>based on options</code>（基于选项如data, methods, computed组织），<br>React 也是state在一个地方统一初始化，然后class里定义一堆一堆的xxx方法，这会导致新接手代码的人阅读逻辑十分困难。  </p>
<p>所以hooks也解决了一个问题，就是我们的代码组织方式可以 <code>based on logical concerns</code>（基于逻辑关注点组织）了<br>不要再按照往常的思维把useState useEffect分门别类的组织起来，看起来整齐但是毫无用处 ！！  </p>
<p>这里上一张vue composition api介绍里对于@vue/ui库中一个组件的对比图</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/29/16cdc53829fba3a5?w=1200&h=1201&f=png&s=266251" alt="对比图"><br>颜色是用来区分功能点的，哪种代码组织方式更利于维护，一目了然了吧。</p>
<p>Vue composition api 推崇的代码组织方式是把逻辑拆分成一个一个的自定hook function，这点和react hook的思路是一致的。</p>
<pre><code class="language-js">export default {
  setup() { // ...
  }
}

function useCurrentFolderData(nextworkState) { // ...
}

function useFolderNavigation({ nextworkState, currentFolderData }) { // ...
}

function useFavoriteFolder(currentFolderData) { // ...
}

function useHiddenFolders() { // ...
}

function useCreateFolder(openFolder) { // ...
}</code></pre>
<p>✔️正确示例</p>
<pre><code class="language-js">import React, { useState, useEffect } from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;
import TodoInput from &quot;./todo-input&quot;;
import TodoList from &quot;./todo-list&quot;;
import { Spin, Tabs } from &quot;antd&quot;;
import { fetchTodos, toggleTodo } from &quot;./api&quot;;
import { useRequest, useWithLoading } from &quot;./hook&quot;;

import &quot;antd/dist/antd.css&quot;;
import &quot;./styles/styles.css&quot;;
import &quot;./styles/reset.css&quot;;

const { TabPane } = Tabs;

const TAB_ALL = &quot;all&quot;;
const TAB_FINISHED = &quot;finished&quot;;
const TAB_UNFINISHED = &quot;unfinished&quot;;
const tabMap = {
  [TAB_ALL]: &quot;全部&quot;,
  [TAB_FINISHED]: &quot;已完成&quot;,
  [TAB_UNFINISHED]: &quot;待完成&quot;
};

function App() {
  const [activeTab, setActiveTab] = useState(TAB_ALL);

  // 数据获取逻辑
  const [query, setQuery] = useState(&quot;&quot;);
  const {
    data: { result: todos = [] },
    loading: listLoading
  } = useRequest(() =&gt; {
    return fetchTodos({ query, tab: activeTab });
  }, [query, activeTab]);

  // placeHolder
  const [placeholder, setPlaceholder] = useState(&quot;&quot;);
  useEffect(() =&gt; {
    setPlaceholder(`在${tabMap[activeTab]}内搜索`);
  }, [activeTab]);

  // 完成todo逻辑
  const { func: onToggleFinished, loading: toggleLoading } = useWithLoading(
    async id =&gt; {
      await toggleTodo(id);
    }
  );

  const loading = !!listLoading || !!toggleLoading;
  return (
    &lt;&gt;
      &lt;Tabs activeKey={activeTab} onChange={setActiveTab}&gt;
        &lt;TabPane tab={tabMap[TAB_ALL]} key={TAB_ALL} /&gt;
        &lt;TabPane tab={tabMap[TAB_FINISHED]} key={TAB_FINISHED} /&gt;
        &lt;TabPane tab={tabMap[TAB_UNFINISHED]} key={TAB_UNFINISHED} /&gt;
      &lt;/Tabs&gt;
      &lt;div className=&quot;app-wrap&quot;&gt;
        &lt;h1 className=&quot;app-title&quot;&gt;Todo List&lt;/h1&gt;
        &lt;TodoInput placeholder={placeholder} onSetQuery={setQuery} /&gt;
        &lt;Spin spinning={loading} tip=&quot;稍等片刻~&quot;&gt;
          &lt;TodoList todos={todos} onToggleFinished={onToggleFinished} /&gt;
        &lt;/Spin&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}
const rootElement = document.getElementById(&quot;root&quot;);
ReactDOM.render(&lt;App /&gt;, rootElement);</code></pre>
<h2 id="总结">总结</h2>
<p>React Hook提供了一种新思路让我们去更好的组织组件内部的逻辑代码，使得功能复杂的大型组件更加易于维护。并且自定义Hook功能十分强大，在公司的项目中我也已经封装了很多好用的自定义Hook比如UseTable, useTreeSearch, useTabs等，可以结合各自公司使用的组件库和ui交互需求把一些逻辑更细粒度的封装起来，发挥你的想象力！useYourImagination!</p>
</div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/487358969","query":{},"buildId":"xOgs5LJb4U_tj9UWKyzRL","nextExport":true,"dynamicIds":["+FGM","+fC4","0kiY","1LUk","28xz","2Vkh","3EHr","3gkP","3wag","4Q+X","4qfg","5VxD","5upZ","6ZBy","6k3J","6quq","73oX","75kF","7P7d","7mzT","7oys","8Kqh","8Pgg","8SK+","9Fqr","9G73","9JLW","9Mhc","9Nr/","9Q8I","9U8A","9c9R","9xzc","AIHI","Aayt","Agkw","AhXs","ApBa","Aqyh","AsRY","B05S","BIHe","BKhn","BLBw","BrQc","CyL5","D68y","DxbC","DzyG","E2cJ","EGmf","FIf5","FJ32","G+vv","G01c","GEZ5","GTAt","GgYO","GwJY","Gxxu","H2RM","H4p3","ImXp","JCUK","JGhL","Jb18","Jjkb","JopO","Jrxr","KK3C","KQfT","KUpP","KcjC","Kjk6","KpOm","KyKy","LOdI","LhHj","Ll1m","Lns6","Lo5G","LptB","MF4s","MQ8/","My+Z","NRrW","NyhX","OZ3z","PGlF","PziN","Q5ZB","QPTg","QQjU","QnJG","RLXu","ROUN","Rq6a","SF9x","SLii","Sl5E","T0rU","TdF3","UCcd","UFGb","UI5O","Uasv","VrLj","WSH0","Wj43","WtIr","Xfvt","YROV","YSo5","ZrqW","alHH","beiO","d4EH","ddo8","dnrZ","dycj","e8E9","ebWy","el66","fDA8","fEaW","fHEK","fP8y","fZ2E","gLO8","gmEm","gst6","hmeD","iTGd","ieeH","iobV","irpp","jKVu","jU8F","jW1C","jctj","kZ3Q","lE5/","lKKg","lRCX","lURu","ldBm","m/If","mBTZ","mY11","mzJY","n3/M","nwyE","o0In","oKc0","oU5B","oVRe","oVqn","on2m","ozyK","phP4","pvv5","pw5m","pxCe","qIW7","qUGr","qZUF","r0Rl","r7oX","rfnV","rnof","s8Vx","sM9k","sbla","syIQ","t6qC","tSgA","tluB","u0OR","u2N3","u34i","uIR8","uQpx","uR4j","unZW","vYiF","wB1n","wi1Z","xj1T","yOV0"]}</script><script async="" data-next-page="/487358969" src="/_next/static/xOgs5LJb4U_tj9UWKyzRL/pages/487358969.js"></script><script async="" data-next-page="/_app" src="/_next/static/xOgs5LJb4U_tj9UWKyzRL/pages/_app.js"></script><script async="" src="/_next/static/chunks/22.bfe4263dd9514139326f.js"></script><script src="/_next/static/runtime/webpack-61b9af2a86c3f75f3f39.js" async=""></script><script src="/_next/static/chunks/commons.d68ea2aa3f883ebc2d53.js" async=""></script><script src="/_next/static/runtime/main-7ca00c6bb257c339c190.js" async=""></script></body></html>